com.gutabi.bypass.BypassApplication -> com.gutabi.bypass.a:
    com.gutabi.bypass.BypassPlatform bypassPlatform -> a
    com.gutabi.bypass.BypassApplication BYPASSAPP -> b
com.gutabi.bypass.BypassPlatform -> com.gutabi.bypass.b:
    void createApplication() -> a
    com.gutabi.bypass.level.LevelDB levelDB(java.lang.String) -> a
    void saveScore(com.gutabi.bypass.level.LevelDB,com.gutabi.bypass.level.Level) -> a
    void clearScores(com.gutabi.bypass.level.LevelDB) -> a
com.gutabi.bypass.android.ActivityState -> com.gutabi.bypass.android.a:
    com.gutabi.bypass.android.ActivityState CREATE -> a
    com.gutabi.bypass.android.ActivityState DESTROY -> b
    com.gutabi.bypass.android.ActivityState START -> c
    com.gutabi.bypass.android.ActivityState STOP -> d
    com.gutabi.bypass.android.ActivityState PAUSE -> e
    com.gutabi.bypass.android.ActivityState RESUME -> f
    com.gutabi.bypass.android.ActivityState RESTART -> g
    com.gutabi.bypass.android.ActivityState[] ENUM$VALUES -> h
    com.gutabi.bypass.android.ActivityState[] values() -> values
    com.gutabi.bypass.android.ActivityState valueOf(java.lang.String) -> valueOf
com.gutabi.bypass.android.BypassActivity -> com.gutabi.bypass.android.b:
    com.gutabi.bypass.android.BypassView v -> a
    com.gutabi.bypass.android.ActivityState state -> b
    java.lang.String name -> c
    void onCreate(android.os.Bundle) -> onCreate
    void onDestroy() -> onDestroy
    void onStart() -> onStart
    void onStop() -> onStop
    void onRestart() -> onRestart
    void onResume() -> onResume
    void onPause() -> onPause
    void onSurfaceChanged(int,int) -> a
    void onSaveInstanceState(android.os.Bundle) -> onSaveInstanceState
    void onRestoreInstanceState(android.os.Bundle) -> onRestoreInstanceState
com.gutabi.bypass.android.BypassAndroidPlatform -> com.gutabi.bypass.android.c:
    com.gutabi.bypass.android.BypassActivity CURRENTACTIVITY -> a
    android.content.res.Resources resources -> b
    com.gutabi.bypass.android.ResourceImpl visitorFontResource -> c
    android.graphics.Paint visitorPlain36 -> d
    android.graphics.Paint visitorPlain16 -> e
    android.graphics.Paint visitorPlain48 -> f
    android.graphics.Paint visitorPlain72 -> g
    android.graphics.Paint imgPaint -> h
    java.util.Map fontBoundsCache -> i
    boolean $assertionsDisabled -> j
    com.gutabi.capsloc.ui.paint.RenderingContext createRenderingContext() -> b
    void setRenderingContextFields1(com.gutabi.capsloc.ui.paint.RenderingContext,java.lang.Object) -> a
    void setRenderingContextFields2(com.gutabi.capsloc.ui.paint.RenderingContext,java.lang.Object,java.lang.Object) -> a
    android.graphics.Paint getFontPaint(com.gutabi.capsloc.Resource,com.gutabi.capsloc.ui.paint.FontStyle,int) -> a
    com.gutabi.capsloc.geom.AABB bounds(java.lang.String,com.gutabi.capsloc.Resource,com.gutabi.capsloc.ui.paint.FontStyle,int) -> a
    com.gutabi.capsloc.ui.Image createImage(int,int) -> a
    com.gutabi.capsloc.ui.Image createTransparentImage(int,int) -> b
    com.gutabi.capsloc.ui.Image readImage(com.gutabi.capsloc.Resource) -> a
    com.gutabi.capsloc.ui.PlatformContentPane createPlatformContentPane() -> c
    void setupAppScreen(java.lang.Object[]) -> a
    void showAppScreen() -> d
    void finishAction() -> e
    com.gutabi.capsloc.Resource fontResource(java.lang.String) -> b
    java.io.InputStream openResourceInputStream(com.gutabi.capsloc.Resource) -> b
    void loadScores(com.gutabi.bypass.level.LevelDB) -> b
    void saveScore(com.gutabi.bypass.level.LevelDB,com.gutabi.bypass.level.Level) -> a
    void clearScores(com.gutabi.bypass.level.LevelDB) -> a
    long monotonicClockMillis() -> f
    com.gutabi.capsloc.geom.GeometryPath createGeometryPath() -> g
com.gutabi.bypass.android.BypassView -> com.gutabi.bypass.android.BypassView:
    com.gutabi.bypass.android.BypassActivity activity -> a
    android.view.SurfaceHolder holder -> b
    boolean surfaceValid -> c
    com.gutabi.capsloc.ui.Paintable paintable -> d
    android.graphics.Paint paint -> e
    com.gutabi.capsloc.ui.paint.RenderingContext ctxt -> f
    void surfaceCreated(android.view.SurfaceHolder) -> surfaceCreated
    void surfaceDestroyed(android.view.SurfaceHolder) -> surfaceDestroyed
    void surfaceChanged(android.view.SurfaceHolder,int,int,int) -> surfaceChanged
    boolean onTouchEvent(android.view.MotionEvent) -> onTouchEvent
    void doDraw(android.graphics.Canvas) -> a
com.gutabi.bypass.android.R -> com.gutabi.bypass.android.d:
com.gutabi.bypass.android.R$id -> com.gutabi.bypass.android.e:
    int btn_levelmenu_clearScores -> btn_levelmenu_clearScores
    int btn_levelmenu_toggleInfo -> btn_levelmenu_toggleInfo
    int btn_world_resetLevel -> btn_world_resetLevel
    int btn_world_toggleInfo -> btn_world_toggleInfo
    int view_bypassworld -> view_bypassworld
    int view_levelmenu -> view_levelmenu
com.gutabi.bypass.android.R$layout -> com.gutabi.bypass.android.f:
    int activity_bypassworld -> activity_bypassworld
    int activity_levelmenu -> activity_levelmenu
com.gutabi.bypass.android.R$menu -> com.gutabi.bypass.android.g:
    int levelmenu_context_menu -> levelmenu_context_menu
    int world_context_menu -> world_context_menu
com.gutabi.bypass.android.ResourceImpl -> com.gutabi.bypass.android.h:
    int resId -> a
    com.gutabi.bypass.android.ResourceType resType -> b
    android.graphics.Typeface face -> c
com.gutabi.bypass.android.ResourceType -> com.gutabi.bypass.android.i:
    com.gutabi.bypass.android.ResourceType DRAWABLE -> a
    com.gutabi.bypass.android.ResourceType RAW -> b
    com.gutabi.bypass.android.ResourceType[] ENUM$VALUES -> c
    com.gutabi.bypass.android.ResourceType[] values() -> values
    com.gutabi.bypass.android.ResourceType valueOf(java.lang.String) -> valueOf
com.gutabi.bypass.android.full.BypassAndroidFullPlatform -> com.gutabi.bypass.android.full.a:
    com.gutabi.bypass.level.LevelDB tutorialLevelDB -> k
    com.gutabi.bypass.level.LevelDB episode1LevelDB -> l
    com.gutabi.bypass.level.LevelDB episode2LevelDB -> m
    void createApplication() -> a
    com.gutabi.bypass.level.LevelDB levelDB(java.lang.String) -> a
    com.gutabi.capsloc.Resource imageResource(java.lang.String) -> c
    com.gutabi.capsloc.Resource levelDBResource(java.lang.String) -> d
    java.lang.String resourceName(com.gutabi.capsloc.Resource) -> c
    void action(java.lang.Class,java.lang.Object[]) -> a
com.gutabi.bypass.android.full.MainMenuActivity -> com.gutabi.bypass.android.full.MainMenuActivity:
    void onCreate(android.os.Bundle) -> onCreate
    void onDestroy() -> onDestroy
    void onStart() -> onStart
    void onStop() -> onStop
    void onResume() -> onResume
    void onSurfaceChanged(int,int) -> a
    void onPause() -> onPause
    void onSaveInstanceState(android.os.Bundle) -> onSaveInstanceState
com.gutabi.bypass.android.geom.GeometryPathImpl -> com.gutabi.bypass.android.a.a:
    android.graphics.Path p -> a
    void reset() -> a
    void add(com.gutabi.capsloc.geom.Circle) -> a
    void add(com.gutabi.capsloc.geom.OBB) -> a
    void add(com.gutabi.capsloc.geom.MutableOBB) -> a
    void add(com.gutabi.capsloc.geom.Triangle) -> a
    void add(com.gutabi.capsloc.geom.MutablePolygon) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.bypass.android.level.BypassWorldActivity -> com.gutabi.bypass.android.level.BypassWorldActivity:
    void onCreate(android.os.Bundle) -> onCreate
    void onStart() -> onStart
    void onStop() -> onStop
    void onResume() -> onResume
    void onSurfaceChanged(int,int) -> a
    void onPause() -> onPause
    void onSaveInstanceState(android.os.Bundle) -> onSaveInstanceState
    boolean onCreateOptionsMenu(android.view.Menu) -> onCreateOptionsMenu
    boolean onOptionsItemSelected(android.view.MenuItem) -> onOptionsItemSelected
com.gutabi.bypass.android.menu.LevelMenuActivity -> com.gutabi.bypass.android.menu.LevelMenuActivity:
    void onCreate(android.os.Bundle) -> onCreate
    void onDestroy() -> onDestroy
    void onStart() -> onStart
    void onStop() -> onStop
    void onResume() -> onResume
    void onSurfaceChanged(int,int) -> a
    void onPause() -> onPause
    void onSaveInstanceState(android.os.Bundle) -> onSaveInstanceState
    boolean onCreateOptionsMenu(android.view.Menu) -> onCreateOptionsMenu
    boolean onOptionsItemSelected(android.view.MenuItem) -> onOptionsItemSelected
com.gutabi.bypass.android.ui.ImageImpl -> com.gutabi.bypass.android.b.a:
    android.graphics.Bitmap b -> a
    int getWidth() -> a
    int getHeight() -> b
com.gutabi.bypass.android.ui.PlatformContentPaneImpl -> com.gutabi.bypass.android.b.b:
    com.gutabi.bypass.android.BypassView v -> a
    void repaint() -> a
com.gutabi.bypass.android.ui.paint.RenderingContextImpl -> com.gutabi.bypass.android.b.a.a:
    float RAD -> a
    android.graphics.Canvas canvas -> b
    android.graphics.Paint paint -> c
    android.graphics.Rect srcRect -> d
    android.graphics.RectF destRect -> e
    boolean $assertionsDisabled -> f
    int[] $SWITCH_TABLE$com$gutabi$capsloc$ui$paint$Cap -> h
    int[] $SWITCH_TABLE$com$gutabi$capsloc$ui$paint$Join -> i
    void rotate(double) -> a
    void paintImage(com.gutabi.capsloc.ui.Image,double,double,double,double,double,int,int,int,int) -> a
    void paintImage(com.gutabi.capsloc.ui.Image,int,int,int,int,int,int,int,int) -> a
    void dispose() -> a
    void setFont(com.gutabi.capsloc.Resource,com.gutabi.capsloc.ui.paint.FontStyle,int) -> a
    void setXORMode(com.gutabi.capsloc.ui.paint.Color) -> a
    void clearXORMode() -> b
    void pushTransform() -> c
    void popTransform() -> d
    void pushClip() -> e
    void popClip() -> f
    void drawAABB(com.gutabi.capsloc.geom.AABB) -> a
    void paintAABB(com.gutabi.capsloc.geom.AABB) -> b
    void drawAABB(com.gutabi.capsloc.geom.MutableAABB) -> a
    void paintPath(com.gutabi.capsloc.geom.GeometryPath) -> a
    void drawLine(com.gutabi.capsloc.geom.Line) -> a
    void paintCircle(com.gutabi.capsloc.geom.Circle) -> a
    void scale(double) -> b
    void setColor(com.gutabi.capsloc.ui.paint.Color) -> b
    void translate(double,double) -> a
    void clip(com.gutabi.capsloc.geom.AABB) -> c
    void setAlpha(double) -> c
    void paintString(double,double,double,java.lang.String) -> a
    void setStroke(double,com.gutabi.capsloc.ui.paint.Cap,com.gutabi.capsloc.ui.paint.Join) -> a
    void setAntialiasing() -> g
    void clearAntialiasing() -> h
    int[] $SWITCH_TABLE$com$gutabi$capsloc$ui$paint$Cap() -> i
    int[] $SWITCH_TABLE$com$gutabi$capsloc$ui$paint$Join() -> j
com.gutabi.bypass.level.BypassCar -> com.gutabi.bypass.a.a:
    char boardLetter -> a
    double coastingVel -> b
    double coastingAcceleration -> c
    boolean $assertionsDisabled -> d
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum -> M
    com.gutabi.bypass.level.BypassCar createCar(com.gutabi.capsloc.world.World,com.gutabi.capsloc.world.sprites.CarSheet$CarType,int,char) -> a
    boolean preStep(double) -> a
    void setCoastingVelFromDrag(com.gutabi.capsloc.math.Point,long,boolean) -> a
    void clearCoastingVel() -> a
    void fakeCoastingStep(double) -> b
    boolean postStep(double) -> c
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum() -> b
com.gutabi.bypass.level.BypassCarTool -> com.gutabi.bypass.a.b:
    com.gutabi.bypass.level.BypassCar car -> a
    com.gutabi.capsloc.math.Point lastPressP -> b
    com.gutabi.capsloc.math.Point lastPanelPressP -> c
    com.gutabi.capsloc.math.Point prevDragP -> d
    com.gutabi.capsloc.math.Point curDragP -> e
    com.gutabi.capsloc.math.Point dragVector -> f
    long prevDragMillis -> g
    long curDragMillis -> h
    long dragTimeStepMillis -> i
    com.gutabi.capsloc.math.Point lastPanelDragP -> j
    com.gutabi.capsloc.math.Point penPanelDragP -> k
    boolean $assertionsDisabled -> l
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum -> n
    void pressed(com.gutabi.capsloc.ui.InputEvent) -> a
    void releasedOrCanceled() -> b
    void released(com.gutabi.capsloc.ui.InputEvent) -> b
    void canceled(com.gutabi.capsloc.ui.InputEvent) -> c
    void determineCoasting(com.gutabi.capsloc.world.graph.GraphPositionPathPosition,com.gutabi.capsloc.world.graph.GraphPositionPathPosition,boolean) -> a
    void dragged(com.gutabi.capsloc.ui.InputEvent) -> d
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum() -> a
com.gutabi.bypass.level.BypassDriver -> com.gutabi.bypass.a.c:
    boolean $assertionsDisabled -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum -> b
    void postStep(double) -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum() -> a
com.gutabi.bypass.level.BypassWorld -> com.gutabi.bypass.a.d:
    java.util.concurrent.locks.ReentrantLock lock -> a
    boolean rendered -> b
    com.gutabi.bypass.level.BypassWorld BYPASSWORLD -> c
    com.gutabi.bypass.level.LevelDB levelDB -> d
    com.gutabi.bypass.level.Level curLevel -> e
    com.gutabi.bypass.level.WinnerMenu winnerMenu -> f
    com.gutabi.capsloc.ui.Label infoLab -> g
    com.gutabi.capsloc.world.graph.BypassBoard bypassBoard -> h
    boolean showInfo -> i
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Side -> B
    boolean $assertionsDisabled -> j
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Axis -> C
    void create(com.gutabi.bypass.level.LevelDB,int) -> a
    void start() -> a_
    void stop() -> b
    void resume() -> c
    void surfaceChanged(int,int) -> a
    void pause() -> d
    void reset() -> e
    com.gutabi.bypass.level.BypassWorld createBypassWorld(com.gutabi.bypass.level.LevelDB,int) -> b
    void addBypassCars(com.gutabi.capsloc.world.graph.BypassBoard) -> a
    void addNewCar(com.gutabi.capsloc.world.graph.BypassBoard,int,int,com.gutabi.capsloc.world.graph.Axis,com.gutabi.capsloc.world.sprites.CarSheet$CarType,int,char) -> a
    com.gutabi.capsloc.ui.Menu getMenu() -> f
    void handlePanning(com.gutabi.capsloc.world.cars.Car,com.gutabi.capsloc.math.Point) -> a
    boolean integrate(double) -> a
    void winner() -> g
    void postDisplay(int,int) -> b
    void render() -> h
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Side() -> i
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Axis() -> j
com.gutabi.bypass.level.Level -> com.gutabi.bypass.a.e:
    int index -> a
    char[][] ini -> b
    int requiredMoves -> c
    int userMoves -> d
    long userTime -> e
    long userStartTime -> f
    boolean isWon -> g
    java.lang.String grade -> h
com.gutabi.bypass.level.LevelDB -> com.gutabi.bypass.a.f:
    java.lang.String resourceName -> a
    java.lang.String title -> b
    int firstUnwon -> c
    double percentage -> d
    java.util.Map levelMap -> h
    com.gutabi.capsloc.Resource res -> e
    int levelCount -> f
    boolean $assertionsDisabled -> g
    void setFirstUnwon() -> a
    void computePercentageComplete() -> b
    com.gutabi.bypass.level.Level getLevel(int) -> a
    void clearLevels() -> c
com.gutabi.bypass.level.WinnerMenu -> com.gutabi.bypass.a.g:
    boolean ready -> a
    void action() -> a
    void postDisplay(int,int) -> a
com.gutabi.bypass.level.WinnerMenu$1 -> com.gutabi.bypass.a.h:
    com.gutabi.bypass.level.WinnerMenu this$0 -> a
    void action() -> a
com.gutabi.bypass.level.WinnerMenu$2 -> com.gutabi.bypass.a.i:
    com.gutabi.bypass.level.WinnerMenu this$0 -> a
    void action() -> a
com.gutabi.bypass.level.WinnerMenu$3 -> com.gutabi.bypass.a.j:
    com.gutabi.bypass.level.WinnerMenu this$0 -> a
    void action() -> a
com.gutabi.bypass.level.WinnerMenu$4 -> com.gutabi.bypass.a.k:
    com.gutabi.bypass.level.WinnerMenu this$0 -> a
    void action() -> a
com.gutabi.bypass.menu.BypassMenu -> com.gutabi.bypass.b.a:
    java.util.concurrent.locks.ReentrantLock lock -> a
    boolean rendered -> b
    com.gutabi.bypass.menu.BypassMenu BYPASSMENU -> c
    java.util.concurrent.atomic.AtomicBoolean simThreadTrigger -> d
    java.lang.Thread simThread -> e
    com.gutabi.capsloc.ui.Menu getMenu() -> f
    double getTime() -> a
    void resume() -> b
    void surfaceChanged(int,int) -> b
    void pause() -> c
    boolean integrate(double) -> a
    void postDisplay(int,int) -> a
    void render() -> d
com.gutabi.bypass.menu.BypassMenuPanel -> com.gutabi.bypass.b.b:
    com.gutabi.capsloc.ui.Image logo -> a
    com.gutabi.capsloc.ui.Image copyright -> b
    double logoAdjustedWidth -> c
    double logoAdjustedHeight -> d
    double copyAdjustedWidth -> e
    double copyAdjustedHeight -> f
    void postDisplay(int,int) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.bypass.menu.LevelMenu -> com.gutabi.bypass.b.c:
    java.lang.String levelDBName -> f
    com.gutabi.bypass.level.LevelDB levelDB -> g
    boolean showInfo -> h
    java.util.Map map -> i
    void updateFirstUnwon() -> e
    void create() -> g
    void destroy() -> h
    void start() -> i
    void stop() -> j
com.gutabi.bypass.menu.LevelMenu$1 -> com.gutabi.bypass.b.d:
    com.gutabi.bypass.menu.LevelMenu this$0 -> a
    int val$ii -> o
    void action() -> a
com.gutabi.bypass.menu.LevelMenuItem -> com.gutabi.bypass.b.e:
    int index -> b
    void render() -> b
com.gutabi.bypass.menu.MainMenu -> com.gutabi.bypass.b.f:
    com.gutabi.bypass.menu.MainMenu MAINMENU -> f
    void updateFirstUnplayed() -> e
    void create() -> g
    void destroy() -> h
    void start() -> i
    void stop() -> j
com.gutabi.bypass.menu.MainMenuFull -> com.gutabi.bypass.b.g:
    com.gutabi.capsloc.ui.MenuItem episode1MenuItem -> g
    com.gutabi.capsloc.ui.MenuItem episode2MenuItem -> h
    com.gutabi.capsloc.ui.MenuItem tutorialMenuItem -> i
    void updateFirstUnplayed() -> e
com.gutabi.bypass.menu.MainMenuFull$1 -> com.gutabi.bypass.b.h:
    com.gutabi.bypass.menu.MainMenuFull this$0 -> a
    void action() -> a
com.gutabi.bypass.menu.MainMenuFull$2 -> com.gutabi.bypass.b.i:
    com.gutabi.bypass.menu.MainMenuFull this$0 -> a
    void action() -> a
com.gutabi.bypass.menu.MainMenuFull$3 -> com.gutabi.bypass.b.j:
    com.gutabi.bypass.menu.MainMenuFull this$0 -> a
    void action() -> a
com.gutabi.bypass.menu.MainMenuItem -> com.gutabi.bypass.b.k:
    com.gutabi.bypass.level.LevelDB levelDB -> b
    void render() -> b
com.gutabi.capsloc.AppScreen -> com.gutabi.a.a:
    com.gutabi.capsloc.ui.ContentPane contentPane -> a
    void postDisplay(int,int) -> a
com.gutabi.capsloc.CapslocApplication -> com.gutabi.a.b:
    com.gutabi.capsloc.world.sprites.Sheet carSheet -> c
    com.gutabi.capsloc.world.sprites.Sheet spriteSheet -> d
    com.gutabi.capsloc.AppScreen appScreen -> e
    com.gutabi.capsloc.Model model -> f
    com.gutabi.capsloc.Tool tool -> g
    com.gutabi.capsloc.Platform platform -> h
    boolean NORMALCAR -> i
    boolean FASTCAR -> j
    boolean REALLYCAR -> k
    boolean TRUCK -> l
    boolean FPS_DRAW -> m
    boolean STOPSIGN_DRAW -> n
    boolean CARTEXTURE_DRAW -> o
    boolean EXPLOSIONS_DRAW -> p
    boolean DEBUG_DRAW -> q
    java.util.Random RANDOM -> r
    com.gutabi.capsloc.CapslocApplication APP -> s
    void setAppScreen(com.gutabi.capsloc.AppScreen) -> a
com.gutabi.capsloc.Entity -> com.gutabi.a.c:
    boolean isUserDeleteable() -> c
    void preStart() -> d
    boolean preStep(double) -> a
    boolean postStep(double) -> c
com.gutabi.capsloc.Integratable -> com.gutabi.a.d:
    boolean integrate(double) -> a
    double getTime() -> a
com.gutabi.capsloc.Model -> com.gutabi.a.e:
    com.gutabi.capsloc.ui.Menu getMenu() -> f
com.gutabi.capsloc.Platform -> com.gutabi.a.f:
    com.gutabi.capsloc.ui.paint.RenderingContext createRenderingContext() -> b
    void setRenderingContextFields1(com.gutabi.capsloc.ui.paint.RenderingContext,java.lang.Object) -> a
    void setRenderingContextFields2(com.gutabi.capsloc.ui.paint.RenderingContext,java.lang.Object,java.lang.Object) -> a
    com.gutabi.capsloc.geom.AABB bounds(java.lang.String,com.gutabi.capsloc.Resource,com.gutabi.capsloc.ui.paint.FontStyle,int) -> a
    com.gutabi.capsloc.ui.Image readImage(com.gutabi.capsloc.Resource) -> a
    com.gutabi.capsloc.ui.Image createImage(int,int) -> a
    com.gutabi.capsloc.ui.Image createTransparentImage(int,int) -> b
    com.gutabi.capsloc.ui.PlatformContentPane createPlatformContentPane() -> c
    void setupAppScreen(java.lang.Object[]) -> a
    void showAppScreen() -> d
    com.gutabi.capsloc.Resource imageResource(java.lang.String) -> c
    com.gutabi.capsloc.Resource fontResource(java.lang.String) -> b
    java.lang.String resourceName(com.gutabi.capsloc.Resource) -> c
    java.io.InputStream openResourceInputStream(com.gutabi.capsloc.Resource) -> b
    com.gutabi.capsloc.geom.GeometryPath createGeometryPath() -> g
    void action(java.lang.Class,java.lang.Object[]) -> a
    void finishAction() -> e
    long monotonicClockMillis() -> f
com.gutabi.capsloc.Resource -> com.gutabi.a.g:
com.gutabi.capsloc.SimulationRunnable -> com.gutabi.a.h:
    java.util.concurrent.atomic.AtomicBoolean trigger -> a
    void run() -> run
com.gutabi.capsloc.Tool -> com.gutabi.a.i:
    void pressed(com.gutabi.capsloc.ui.InputEvent) -> a
    void released(com.gutabi.capsloc.ui.InputEvent) -> b
    void dragged(com.gutabi.capsloc.ui.InputEvent) -> d
    void canceled(com.gutabi.capsloc.ui.InputEvent) -> c
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.geom.AABB -> com.gutabi.a.a.a:
    com.gutabi.capsloc.math.Dim dim -> a
    double x -> b
    double y -> c
    double width -> d
    double height -> e
    double brX -> f
    double brY -> g
    double centerX -> h
    double centerY -> i
    com.gutabi.capsloc.math.Point n01 -> j
    com.gutabi.capsloc.math.Point n12 -> k
    double[] n01Projection -> l
    double[] n12Projection -> m
    com.gutabi.capsloc.geom.Line p0p1Line -> n
    com.gutabi.capsloc.geom.Line p1p2Line -> o
    com.gutabi.capsloc.geom.Line p2p3Line -> p
    com.gutabi.capsloc.geom.Line p3p0Line -> q
    int hash -> r
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    com.gutabi.capsloc.geom.AABB getAABB() -> a
    void project(com.gutabi.capsloc.math.Point,double[]) -> a
    com.gutabi.capsloc.math.Point closestCornerTo(com.gutabi.capsloc.math.Point) -> a
    void computeProjections() -> h
    com.gutabi.capsloc.math.Point getN01() -> b
    com.gutabi.capsloc.math.Point getN12() -> c
    void projectN01(double[]) -> a
    void projectN12(double[]) -> b
    com.gutabi.capsloc.geom.Line getP0P1Line() -> d
    com.gutabi.capsloc.geom.Line getP1P2Line() -> e
    com.gutabi.capsloc.geom.Line getP2P3Line() -> f
    com.gutabi.capsloc.geom.Line getP3P0Line() -> g
    boolean hitTest(com.gutabi.capsloc.math.Point) -> b
    com.gutabi.capsloc.geom.AABB union(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.AABB) -> a
    com.gutabi.capsloc.geom.AABB intersection(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.AABB) -> b
    void draw(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
com.gutabi.capsloc.geom.Capsule -> com.gutabi.a.a.b:
    com.gutabi.capsloc.geom.Circle ac -> a
    com.gutabi.capsloc.geom.Circle bc -> b
    com.gutabi.capsloc.geom.OBB middle -> c
    com.gutabi.capsloc.math.Point a -> d
    com.gutabi.capsloc.math.Point b -> e
    double r -> f
    com.gutabi.capsloc.math.Point aUp -> g
    com.gutabi.capsloc.math.Point aDown -> h
    com.gutabi.capsloc.math.Point bUp -> i
    com.gutabi.capsloc.math.Point bDown -> j
    com.gutabi.capsloc.geom.Line debugNormalLine -> m
    com.gutabi.capsloc.geom.Line debugSkeletonLine -> n
    com.gutabi.capsloc.geom.AABB aabb -> k
    com.gutabi.capsloc.geom.Line abUp -> o
    com.gutabi.capsloc.geom.Line baDown -> p
    com.gutabi.capsloc.geom.GeometryPath path -> q
    int hash -> r
    boolean $assertionsDisabled -> l
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    com.gutabi.capsloc.math.Point getPoint(double) -> a
    double findSkeletonIntersection(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> a
    com.gutabi.capsloc.geom.Line getABUp() -> a
    com.gutabi.capsloc.geom.Line getBADown() -> b
    void drawSkeleton(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.geom.CapsuleSequence -> com.gutabi.a.a.c:
    java.util.List caps -> a
    int capsuleCount -> b
    double radius -> c
    com.gutabi.capsloc.geom.AABB aabb -> d
    com.gutabi.capsloc.geom.GeometryPath path -> e
    boolean $assertionsDisabled -> f
    com.gutabi.capsloc.geom.Capsule getCapsule(int) -> a
    double getRadius() -> a
    com.gutabi.capsloc.math.Point getPoint(int) -> b
    com.gutabi.capsloc.math.Point getPoint(int,double) -> a
    int capsuleCount() -> b
    int pointCount() -> c
    com.gutabi.capsloc.geom.Circle getStart() -> d
    com.gutabi.capsloc.geom.CapsuleSequence subsequence(int) -> c
    void capseq(int,com.gutabi.capsloc.geom.MutableCapsuleSequence) -> a
    com.gutabi.capsloc.geom.AABB getAABB() -> e
    com.gutabi.capsloc.geom.CapsuleSequencePosition findSkeletonIntersection(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> a
    com.gutabi.capsloc.geom.CapsuleSequencePosition findClosestStrokePosition(com.gutabi.capsloc.math.Point,double) -> a
    double closestParam(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.geom.Capsule) -> a
    boolean intersect(java.lang.Object) -> a
    boolean intersectA(com.gutabi.capsloc.geom.AABB) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void drawSkeleton(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
com.gutabi.capsloc.geom.CapsuleSequencePosition -> com.gutabi.a.a.d:
    com.gutabi.capsloc.geom.CapsuleSequence seq -> a
    int index -> b
    double param -> c
    com.gutabi.capsloc.math.Point p -> d
com.gutabi.capsloc.geom.CapsuleSequenceSweepEvent -> com.gutabi.a.a.e:
    com.gutabi.capsloc.geom.Circle circle -> a
    boolean $assertionsDisabled -> b
com.gutabi.capsloc.geom.Circle -> com.gutabi.a.a.f:
    com.gutabi.capsloc.math.Point center -> a
    double radius -> b
    com.gutabi.capsloc.geom.AABB aabb -> c
    int hash -> e
    boolean $assertionsDisabled -> d
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    void project(com.gutabi.capsloc.math.Point,double[]) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.geom.CompoundShape -> com.gutabi.a.a.g:
    boolean intersect(java.lang.Object) -> a
com.gutabi.capsloc.geom.CubicCurve -> com.gutabi.a.a.h:
    com.gutabi.capsloc.math.Point p0 -> a
    com.gutabi.capsloc.math.Point c0 -> b
    com.gutabi.capsloc.math.Point c1 -> c
    com.gutabi.capsloc.math.Point p1 -> d
    com.gutabi.capsloc.math.Point point(double) -> a
    java.util.List skeleton() -> a
com.gutabi.capsloc.geom.Geom -> com.gutabi.a.a.i:
    com.gutabi.capsloc.math.Point times(double[][],com.gutabi.capsloc.math.Point) -> a
    com.gutabi.capsloc.math.Point rotateAndAdd(double,double,double,com.gutabi.capsloc.math.Point) -> a
    int halfPlane(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> a
    com.gutabi.capsloc.geom.OBB localToWorld(com.gutabi.capsloc.geom.AABB,double,com.gutabi.capsloc.math.Point) -> a
    void localToWorld(com.gutabi.capsloc.geom.AABB,double,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.geom.MutableOBB) -> a
    void localToWorldAndTakeAABB(com.gutabi.capsloc.geom.AABB,double,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.geom.MutableAABB) -> a
com.gutabi.capsloc.geom.GeometryPath -> com.gutabi.a.a.j:
    void reset() -> a
    void add(com.gutabi.capsloc.geom.Circle) -> a
    void add(com.gutabi.capsloc.geom.OBB) -> a
    void add(com.gutabi.capsloc.geom.MutableOBB) -> a
    void add(com.gutabi.capsloc.geom.Triangle) -> a
    void add(com.gutabi.capsloc.geom.MutablePolygon) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.geom.Line -> com.gutabi.a.a.k:
    com.gutabi.capsloc.math.Point p0 -> a
    com.gutabi.capsloc.math.Point p1 -> b
    com.gutabi.capsloc.math.Point n01 -> c
    double[] n01Projection -> d
    int hash -> f
    boolean rightAngle -> e
    int hashCode() -> hashCode
    com.gutabi.capsloc.math.Point getN01() -> a
    void computeN01() -> b
    void computeProjections() -> c
    void project(com.gutabi.capsloc.math.Point,double[]) -> a
    void projectN01(double[]) -> a
    void draw(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.geom.MutableAABB -> com.gutabi.a.a.l:
    double x -> a
    double y -> b
    double width -> c
    double height -> d
    com.gutabi.capsloc.math.Point n01 -> e
    com.gutabi.capsloc.math.Point n12 -> f
    double[] n01Projection -> h
    double[] n12Projection -> i
    boolean $assertionsDisabled -> g
    void reset() -> a
    void setShape(double,double,double,double) -> a
    com.gutabi.capsloc.geom.AABB copy() -> b
    void union(com.gutabi.capsloc.geom.AABB) -> a
    boolean completelyWithin(com.gutabi.capsloc.geom.AABB) -> b
    double fractionWithin(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.AABB) -> a
    void project(com.gutabi.capsloc.math.Point,double[]) -> a
    com.gutabi.capsloc.math.Point getN01() -> c
    com.gutabi.capsloc.math.Point getN12() -> d
    void projectN01(double[]) -> a
    void projectN12(double[]) -> b
    void computeProjections() -> e
    void draw(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.geom.MutableCapsuleSequence -> com.gutabi.a.a.m:
    java.util.List caps -> a
    double radius -> b
    com.gutabi.capsloc.geom.MutableAABB aabb -> c
    boolean $assertionsDisabled -> d
    void setCapSeq(java.util.List) -> a
    com.gutabi.capsloc.math.Point getPoint(int,double) -> a
    double getRadius() -> a
    com.gutabi.capsloc.geom.Capsule getCapsule(int) -> a
    com.gutabi.capsloc.geom.Circle getStart() -> b
com.gutabi.capsloc.geom.MutableOBB -> com.gutabi.a.a.n:
    com.gutabi.capsloc.math.Point center -> a
    double a -> b
    double xExtant -> c
    double yExtant -> d
    com.gutabi.capsloc.math.Point p0 -> e
    com.gutabi.capsloc.math.Point p1 -> f
    com.gutabi.capsloc.math.Point p2 -> g
    com.gutabi.capsloc.math.Point p3 -> h
    com.gutabi.capsloc.math.Point n01 -> r
    com.gutabi.capsloc.math.Point n12 -> s
    double[] n01Projection -> i
    double[] n12Projection -> j
    com.gutabi.capsloc.geom.Line p0p1Line -> k
    com.gutabi.capsloc.geom.Line p1p2Line -> l
    com.gutabi.capsloc.geom.Line p2p3Line -> m
    com.gutabi.capsloc.geom.Line p3p0Line -> n
    boolean rightAngle -> o
    com.gutabi.capsloc.geom.MutableAABB aabb -> p
    int hash -> t
    boolean $assertionsDisabled -> q
    void setShape(com.gutabi.capsloc.math.Point,double,double,double) -> a
    void copy(com.gutabi.capsloc.geom.MutableOBB) -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    void computeProjections() -> c
    void computeN01() -> d
    void computeN12() -> e
    com.gutabi.capsloc.math.Point getN01() -> a
    com.gutabi.capsloc.math.Point getN12() -> b
    boolean hitTest(com.gutabi.capsloc.math.Point) -> a
    com.gutabi.capsloc.math.Point closestCornerTo(com.gutabi.capsloc.math.Point) -> b
    void project(com.gutabi.capsloc.math.Point,double[]) -> a
    void projectN01(double[]) -> a
    void projectN12(double[]) -> b
com.gutabi.capsloc.geom.MutablePolygon -> com.gutabi.a.a.o:
    double[][] pts -> a
    void setPoints(double,double,double,double,double,double,double,double) -> a
com.gutabi.capsloc.geom.MutableSweptOBB -> com.gutabi.a.a.p:
    com.gutabi.capsloc.geom.MutableOBB start -> a
    com.gutabi.capsloc.geom.MutableOBB end -> b
    boolean isAABB -> c
    com.gutabi.capsloc.geom.MutableAABB aabb -> d
    double dist -> e
    com.gutabi.capsloc.math.Point dir -> f
    int hash -> g
    void setShape(com.gutabi.capsloc.geom.MutableOBB,com.gutabi.capsloc.geom.MutableOBB) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
com.gutabi.capsloc.geom.OBB -> com.gutabi.a.a.q:
    com.gutabi.capsloc.math.Point center -> a
    double a -> b
    double xExtant -> c
    double yExtant -> d
    com.gutabi.capsloc.math.Point p0 -> e
    com.gutabi.capsloc.math.Point p1 -> f
    com.gutabi.capsloc.math.Point p2 -> g
    com.gutabi.capsloc.math.Point p3 -> h
    com.gutabi.capsloc.math.Point n01 -> n
    com.gutabi.capsloc.math.Point n12 -> o
    double[] n01Projection -> i
    double[] n12Projection -> j
    boolean rightAngle -> k
    com.gutabi.capsloc.geom.AABB aabb -> l
    int hash -> p
    boolean $assertionsDisabled -> m
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    void computeProjections() -> c
    void computeN01() -> d
    void computeN12() -> e
    com.gutabi.capsloc.math.Point getN01() -> a
    com.gutabi.capsloc.math.Point getN12() -> b
    com.gutabi.capsloc.math.Point closestCornerTo(com.gutabi.capsloc.math.Point) -> a
    void project(com.gutabi.capsloc.math.Point,double[]) -> a
    void projectN01(double[]) -> a
    void projectN12(double[]) -> b
com.gutabi.capsloc.geom.ShapeUtils -> com.gutabi.a.a.r:
    boolean $assertionsDisabled -> a
    boolean intersect(java.lang.Object,java.lang.Object) -> a
    boolean intersectArea(java.lang.Object,java.lang.Object) -> b
    boolean touch(java.lang.Object,java.lang.Object) -> c
    boolean contains(java.lang.Object,java.lang.Object) -> d
    boolean intersectAA(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.AABB) -> a
    boolean intersectAA(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.MutableAABB) -> a
    boolean intersectAA(com.gutabi.capsloc.geom.MutableAABB,com.gutabi.capsloc.geom.MutableAABB) -> a
    boolean intersectACap(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.Capsule) -> a
    boolean intersectAC(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.Circle) -> a
    boolean intersectAO(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.OBB) -> a
    boolean intersectAO(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.MutableOBB) -> a
    boolean intersectCapCap(com.gutabi.capsloc.geom.Capsule,com.gutabi.capsloc.geom.Capsule) -> a
    boolean intersectCapC(com.gutabi.capsloc.geom.Capsule,com.gutabi.capsloc.geom.Circle) -> a
    boolean intersectCapO(com.gutabi.capsloc.geom.Capsule,com.gutabi.capsloc.geom.OBB) -> a
    boolean intersectCC(com.gutabi.capsloc.geom.Circle,com.gutabi.capsloc.geom.Circle) -> a
    boolean intersectCO(com.gutabi.capsloc.geom.Circle,com.gutabi.capsloc.geom.OBB) -> a
    boolean intersectCO(com.gutabi.capsloc.geom.Circle,com.gutabi.capsloc.geom.MutableOBB) -> a
    boolean intersectOO(com.gutabi.capsloc.geom.OBB,com.gutabi.capsloc.geom.OBB) -> a
    boolean intersectAreaAA(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.MutableAABB) -> b
    boolean intersectAreaAA(com.gutabi.capsloc.geom.MutableAABB,com.gutabi.capsloc.geom.MutableAABB) -> b
    boolean intersectAreaAL(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.Line) -> a
    boolean intersectAreaAL(com.gutabi.capsloc.geom.MutableAABB,com.gutabi.capsloc.geom.Line) -> a
    boolean intersectAreaAO(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.OBB) -> b
    boolean intersectAreaLO(com.gutabi.capsloc.geom.Line,com.gutabi.capsloc.geom.OBB) -> a
    boolean containsAO(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.OBB) -> c
    boolean containsAO(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.MutableOBB) -> b
    boolean touchCapC(com.gutabi.capsloc.geom.Capsule,com.gutabi.capsloc.geom.Circle) -> b
    boolean touchCC(com.gutabi.capsloc.geom.Circle,com.gutabi.capsloc.geom.Circle) -> b
com.gutabi.capsloc.geom.SweepEvent -> com.gutabi.a.a.s:
    com.gutabi.capsloc.geom.SweepEventType type -> c
    java.lang.Object stillParent -> d
    java.lang.Object still -> e
    com.gutabi.capsloc.geom.SweeperShape moving -> f
    int index -> g
    double param -> h
    double combo -> i
    com.gutabi.capsloc.math.Point p -> j
    com.gutabi.capsloc.world.graph.Vertex v -> k
    boolean inRoad -> l
    java.util.Comparator COMPARATOR -> m
    java.lang.String toString() -> toString
com.gutabi.capsloc.geom.SweepEvent$SweepEventComparator -> com.gutabi.a.a.t:
    int compare(com.gutabi.capsloc.geom.SweepEvent,com.gutabi.capsloc.geom.SweepEvent) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
com.gutabi.capsloc.geom.SweepEventType -> com.gutabi.a.a.u:
    com.gutabi.capsloc.geom.SweepEventType ENTERROADCAPSULE -> a
    com.gutabi.capsloc.geom.SweepEventType EXITROADCAPSULE -> b
    com.gutabi.capsloc.geom.SweepEventType ENTERROAD -> c
    com.gutabi.capsloc.geom.SweepEventType EXITROAD -> d
    com.gutabi.capsloc.geom.SweepEventType ENTERVERTEX -> e
    com.gutabi.capsloc.geom.SweepEventType EXITVERTEX -> f
    com.gutabi.capsloc.geom.SweepEventType ENTERMERGER -> g
    com.gutabi.capsloc.geom.SweepEventType EXITMERGER -> h
    com.gutabi.capsloc.geom.SweepEventType ENTERSTROKE -> i
    com.gutabi.capsloc.geom.SweepEventType EXITSTROKE -> j
    com.gutabi.capsloc.geom.SweepEventType ENTERBOARD -> k
    com.gutabi.capsloc.geom.SweepEventType EXITBOARD -> l
    com.gutabi.capsloc.geom.SweepEventType ENTERCAR -> m
    com.gutabi.capsloc.geom.SweepEventType EXITCAR -> n
    boolean $assertionsDisabled -> o
    com.gutabi.capsloc.geom.SweepEventType[] ENUM$VALUES -> p
    com.gutabi.capsloc.geom.SweepEventType enter(java.lang.Object) -> a
    com.gutabi.capsloc.geom.SweepEventType exit(java.lang.Object) -> b
    com.gutabi.capsloc.geom.SweepEventType[] values() -> values
    com.gutabi.capsloc.geom.SweepEventType valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.geom.SweepUtils -> com.gutabi.a.a.v:
    boolean $assertionsDisabled -> a
    java.util.List sweepStartCSoverA(java.lang.Object,com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.CapsuleSequence,int) -> a
    java.util.List sweepCSoverA(java.lang.Object,com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.MutableCapsuleSequence,int,int) -> a
    java.util.List sweepStartCSoverCap(java.lang.Object,com.gutabi.capsloc.geom.Capsule,com.gutabi.capsloc.geom.CapsuleSequence,int) -> a
    java.util.List sweepStartCSoverCap(java.lang.Object,com.gutabi.capsloc.geom.Capsule,com.gutabi.capsloc.geom.MutableCapsuleSequence,int) -> a
    java.util.List sweepCSoverCap(java.lang.Object,com.gutabi.capsloc.geom.Capsule,com.gutabi.capsloc.geom.MutableCapsuleSequence,int,int) -> a
    java.util.List sweepStartCSoverCS(java.lang.Object,com.gutabi.capsloc.geom.CapsuleSequence,com.gutabi.capsloc.geom.CapsuleSequence,int) -> a
    java.util.List sweepStartCSoverCS(java.lang.Object,com.gutabi.capsloc.geom.CapsuleSequence,com.gutabi.capsloc.geom.MutableCapsuleSequence,int) -> a
    java.util.List sweepCSoverCS(java.lang.Object,com.gutabi.capsloc.geom.CapsuleSequence,com.gutabi.capsloc.geom.MutableCapsuleSequence,int,int) -> a
    java.util.List sweepStartCSoverC(java.lang.Object,com.gutabi.capsloc.geom.Circle,com.gutabi.capsloc.geom.CapsuleSequence,int) -> a
    java.util.List sweepCSoverC(java.lang.Object,com.gutabi.capsloc.geom.Circle,com.gutabi.capsloc.geom.MutableCapsuleSequence,int,int) -> a
    double sweepCircleOverLine(com.gutabi.capsloc.geom.Line,com.gutabi.capsloc.geom.Capsule) -> a
    int sweepCircleOverCircle(com.gutabi.capsloc.geom.Circle,com.gutabi.capsloc.geom.Capsule,double[]) -> a
    double firstCollisionParam(com.gutabi.capsloc.geom.Line,com.gutabi.capsloc.geom.SweptOBB) -> a
    double firstCollisionParam(com.gutabi.capsloc.geom.Line,com.gutabi.capsloc.geom.MutableSweptOBB) -> a
    double firstCollisionParam(com.gutabi.capsloc.geom.MutableOBB,com.gutabi.capsloc.geom.SweptOBB) -> a
    double firstCollisionParam(com.gutabi.capsloc.geom.MutableOBB,com.gutabi.capsloc.geom.MutableSweptOBB) -> a
com.gutabi.capsloc.geom.SweeperShape -> com.gutabi.a.a.w:
com.gutabi.capsloc.geom.SweptOBB -> com.gutabi.a.a.x:
    com.gutabi.capsloc.geom.OBB start -> a
    com.gutabi.capsloc.geom.OBB end -> b
    boolean isAABB -> c
    com.gutabi.capsloc.geom.AABB aabb -> d
    double dist -> e
    com.gutabi.capsloc.math.Point dir -> f
    int hash -> g
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
com.gutabi.capsloc.geom.Triangle -> com.gutabi.a.a.y:
    com.gutabi.capsloc.math.Point p0 -> a
    com.gutabi.capsloc.math.Point p1 -> b
    com.gutabi.capsloc.math.Point p2 -> c
com.gutabi.capsloc.math.ColinearException -> com.gutabi.a.b.a:
com.gutabi.capsloc.math.DMath -> com.gutabi.a.b.b:
    java.util.Comparator COMPARATOR -> a
    boolean equals(double,double) -> a
    boolean lessThanEquals(double,double) -> b
    boolean greaterThanEquals(double,double) -> c
    boolean lessThan(double,double) -> d
    boolean greaterThan(double,double) -> e
    boolean rangesOverlap(double[],double[]) -> a
    boolean rangesOverlapArea(double[],double[]) -> b
    boolean rangesOverlapArea(double,double,double,double) -> a
    boolean rangeContains(double[],double[]) -> c
    double sgn(double) -> a
    double quadraticSolve(double,double,double,double[]) -> a
    double lerp(double,double,double) -> a
    double tryAdjustToRightAngle(double) -> b
    double tryAdjustToReducedRightAngle(double) -> c
    boolean isRightAngle(double) -> d
    boolean anglesCompatible(double,double) -> f
com.gutabi.capsloc.math.DMath$DoubleComparator -> com.gutabi.a.b.c:
    int compare(java.lang.Double,java.lang.Double) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
com.gutabi.capsloc.math.Dim -> com.gutabi.a.b.d:
    double width -> a
    double height -> b
    int hash -> c
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
com.gutabi.capsloc.math.OverlappingException -> com.gutabi.a.b.e:
    com.gutabi.capsloc.math.Point a -> a
    com.gutabi.capsloc.math.Point b -> b
    com.gutabi.capsloc.math.Point c -> c
    com.gutabi.capsloc.math.Point d -> d
com.gutabi.capsloc.math.Point -> com.gutabi.a.b.f:
    com.gutabi.capsloc.math.Point UP -> a
    com.gutabi.capsloc.math.Point DOWN -> b
    com.gutabi.capsloc.math.Point LEFT -> c
    com.gutabi.capsloc.math.Point RIGHT -> d
    double x -> e
    double y -> f
    int hash -> h
    boolean $assertionsDisabled -> g
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    double distanceTo(com.gutabi.capsloc.math.Point) -> a
    com.gutabi.capsloc.math.Point intersection(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> a
    com.gutabi.capsloc.math.Point point(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,double) -> a
    double travelForward(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,double,double) -> a
    double travelBackward(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,double,double) -> b
    boolean intersect(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> a
    boolean colinear(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> b
    double u(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> c
    double uNoProjection(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> d
    double distance(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> e
    double param(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> f
    double param(double,double,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> a
    double distance(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> a
    double distance(double,double,double,double) -> a
    int circleLineIntersections(com.gutabi.capsloc.math.Point,double,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point[]) -> a
    int circleSegmentIntersections(com.gutabi.capsloc.math.Point,double,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point[]) -> b
    double dot(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> b
    com.gutabi.capsloc.math.Point cw90AndNormalize(com.gutabi.capsloc.math.Point) -> b
    com.gutabi.capsloc.math.Point ccw90AndNormalize(com.gutabi.capsloc.math.Point) -> c
    com.gutabi.capsloc.math.Point normalize() -> a
    com.gutabi.capsloc.math.Point normalize(double,double) -> a
    boolean isRightAngleNormal() -> b
    double length() -> c
    com.gutabi.capsloc.math.Point multiply(double) -> a
    com.gutabi.capsloc.math.Point plus(com.gutabi.capsloc.math.Point) -> d
    com.gutabi.capsloc.math.Point minus(com.gutabi.capsloc.math.Point) -> e
    com.gutabi.capsloc.math.Point minus(double,double) -> b
    com.gutabi.capsloc.math.Point minusAndNormalize(com.gutabi.capsloc.math.Point) -> f
    com.gutabi.capsloc.math.Point negate() -> d
    double lengthSquared() -> e
    com.gutabi.capsloc.math.Point panelToWorld(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.world.WorldCamera) -> a
    com.gutabi.capsloc.math.Point worldToPanel(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.world.WorldCamera) -> b
    com.gutabi.capsloc.math.Point worldToPanel(double,double,com.gutabi.capsloc.world.WorldCamera) -> a
    void worldToPanel(com.gutabi.capsloc.geom.MutableAABB,com.gutabi.capsloc.world.WorldCamera,com.gutabi.capsloc.geom.MutableAABB) -> a
    com.gutabi.capsloc.math.Point panelToMenu(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.ui.Menu) -> a
    com.gutabi.capsloc.math.Point contentPaneToPanel(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.ui.Panel) -> a
com.gutabi.capsloc.ui.ContentPane -> com.gutabi.a.c.a:
    com.gutabi.capsloc.ui.PlatformContentPane pcp -> a
    void postDisplay(int,int) -> a
    void repaint() -> a
com.gutabi.capsloc.ui.Image -> com.gutabi.a.c.b:
    int getWidth() -> a
    int getHeight() -> b
com.gutabi.capsloc.ui.InputEvent -> com.gutabi.a.c.c:
    com.gutabi.capsloc.math.Point p -> a
    com.gutabi.capsloc.ui.Panel panel -> b
com.gutabi.capsloc.ui.Label -> com.gutabi.a.c.d:
    java.lang.String text -> a
    com.gutabi.capsloc.Resource fontFile -> b
    com.gutabi.capsloc.ui.paint.FontStyle fontStyle -> c
    int fontSize -> d
    com.gutabi.capsloc.ui.paint.Color color -> e
    com.gutabi.capsloc.geom.AABB localAABB -> f
    com.gutabi.capsloc.geom.AABB aabb -> g
    void setLocation(double,double) -> a
    void renderLocal() -> a
    void render() -> b
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.ui.Menu -> com.gutabi.a.c.e:
    java.util.List tree -> j
    java.util.List colAABBs -> k
    com.gutabi.capsloc.ui.MenuItem hilited -> l
    com.gutabi.capsloc.ui.MenuItem firstMenuItem -> m
    com.gutabi.capsloc.ui.MenuItem shimmeringMenuItem -> n
    int rows -> o
    int cols -> p
    double[] columnWidth -> q
    double[] columnHeight -> r
    com.gutabi.capsloc.geom.AABB aabb -> s
    com.gutabi.capsloc.geom.AABB marginAABB -> t
    com.gutabi.capsloc.math.Point panelOffset -> u
    int parWidth -> v
    int parHeight -> w
    double widthFraction -> x
    double scale -> y
    double menuWidth -> z
    double menuHeight -> A
    boolean hScrollable -> B
    boolean vScrollable -> C
    com.gutabi.capsloc.ui.Shimmer shimmer -> D
    void setLocation(double,double) -> a
    void setLocation(com.gutabi.capsloc.math.Point) -> a
    void add(com.gutabi.capsloc.ui.MenuItem,int,int) -> a
    void pressed(com.gutabi.capsloc.ui.InputEvent) -> a
    void released(com.gutabi.capsloc.ui.InputEvent) -> b
    void canceled(com.gutabi.capsloc.ui.InputEvent) -> c
    void dragToNewLocation(com.gutabi.capsloc.math.Point) -> b
    com.gutabi.capsloc.ui.MenuItem hitTest(com.gutabi.capsloc.math.Point) -> c
    boolean integrate(double) -> a
    void postDisplay(int,int) -> a
    void render() -> d
    void setAABBAndScrolling() -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.ui.MenuItem -> com.gutabi.a.c.f:
    com.gutabi.capsloc.ui.Menu menu -> c
    com.gutabi.capsloc.ui.Label lab -> d
    com.gutabi.capsloc.ui.Label auxLab0 -> e
    com.gutabi.capsloc.ui.Label auxLab1 -> f
    com.gutabi.capsloc.ui.Label auxLab2 -> g
    boolean border -> h
    com.gutabi.capsloc.geom.AABB localAABB -> i
    com.gutabi.capsloc.geom.AABB aabb -> j
    boolean active -> k
    int r -> l
    int c -> m
    com.gutabi.capsloc.ui.MenuItem minimumWidth -> n
    boolean hitTest(com.gutabi.capsloc.math.Point) -> a
    void action() -> a
    void render() -> b
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintHilited(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
com.gutabi.capsloc.ui.MenuItem$1 -> com.gutabi.a.c.g:
    void action() -> a
com.gutabi.capsloc.ui.MenuTool -> com.gutabi.a.c.h:
    com.gutabi.capsloc.math.Point origMenuUL -> a
    com.gutabi.capsloc.math.Point origPressed -> b
    void pressed(com.gutabi.capsloc.ui.InputEvent) -> a
    void dragged(com.gutabi.capsloc.ui.InputEvent) -> d
    void released(com.gutabi.capsloc.ui.InputEvent) -> b
    void canceled(com.gutabi.capsloc.ui.InputEvent) -> c
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.ui.Paintable -> com.gutabi.a.c.i:
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.ui.Panel -> com.gutabi.a.c.j:
    com.gutabi.capsloc.geom.AABB aabb -> g
    com.gutabi.capsloc.math.Point lastMovedOrDraggedPanelPoint -> h
    com.gutabi.capsloc.math.Point lastPressedPanelPoint -> i
    com.gutabi.capsloc.math.Point lastDraggedPanelPoint -> j
    void pressed(com.gutabi.capsloc.ui.InputEvent) -> a
    void released(com.gutabi.capsloc.ui.InputEvent) -> b
    void dragged(com.gutabi.capsloc.ui.InputEvent) -> c
    void canceled(com.gutabi.capsloc.ui.InputEvent) -> d
    void postDisplay(int,int) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.ui.PlatformContentPane -> com.gutabi.a.c.k:
    java.util.List children -> b
    com.gutabi.capsloc.math.Point lastPressedContentPanePoint -> a
    com.gutabi.capsloc.math.Point lastDraggedContentPanePoint -> c
    java.util.List getChildren() -> b
    void pressedDriver(com.gutabi.capsloc.math.Point) -> a
    void releasedDriver(com.gutabi.capsloc.math.Point) -> b
    void canceledDriver() -> c
    void draggedDriver(com.gutabi.capsloc.math.Point) -> c
    void postDisplay(int,int) -> a
    void repaint() -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.ui.Shimmer -> com.gutabi.a.c.l:
    double x -> a
    double y -> b
    double width -> c
    double height -> d
    double brX -> e
    double brY -> f
    double startMillis -> g
    com.gutabi.capsloc.geom.MutablePolygon poly -> h
    com.gutabi.capsloc.geom.GeometryPath path -> i
    double traverseSpeed -> j
    double timeToRest -> k
    double timeToTraverse -> l
    double t -> m
    boolean alreadyRested -> n
    boolean $assertionsDisabled -> o
    void setShape(com.gutabi.capsloc.geom.AABB) -> a
    void setShape(com.gutabi.capsloc.geom.MutableAABB) -> a
    boolean step() -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.ui.paint.Cap -> com.gutabi.a.c.a.a:
    com.gutabi.capsloc.ui.paint.Cap BUTT -> a
    com.gutabi.capsloc.ui.paint.Cap ROUND -> b
    com.gutabi.capsloc.ui.paint.Cap SQUARE -> c
    com.gutabi.capsloc.ui.paint.Cap[] ENUM$VALUES -> d
    com.gutabi.capsloc.ui.paint.Cap[] values() -> values
    com.gutabi.capsloc.ui.paint.Cap valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.ui.paint.Color -> com.gutabi.a.c.a.b:
    com.gutabi.capsloc.ui.paint.Color ROADCOLOR -> a
    com.gutabi.capsloc.ui.paint.Color FIXTURECOLOR -> b
    com.gutabi.capsloc.ui.paint.Color RED -> c
    com.gutabi.capsloc.ui.paint.Color ORANGE -> d
    com.gutabi.capsloc.ui.paint.Color YELLOW -> e
    com.gutabi.capsloc.ui.paint.Color GREEN -> f
    com.gutabi.capsloc.ui.paint.Color LIGHTGREEN -> g
    com.gutabi.capsloc.ui.paint.Color DARKGREEN -> h
    com.gutabi.capsloc.ui.paint.Color BLUE -> i
    com.gutabi.capsloc.ui.paint.Color WHITE -> j
    com.gutabi.capsloc.ui.paint.Color GRAY -> k
    com.gutabi.capsloc.ui.paint.Color LIGHT_GRAY -> l
    com.gutabi.capsloc.ui.paint.Color DARK_GRAY -> m
    com.gutabi.capsloc.ui.paint.Color BLACK -> n
    com.gutabi.capsloc.ui.paint.Color menuBackground -> o
    com.gutabi.capsloc.ui.paint.Color brown -> p
    com.gutabi.capsloc.ui.paint.Color redOrange -> q
    com.gutabi.capsloc.ui.paint.Color fixtureHiliteColor -> r
    com.gutabi.capsloc.ui.paint.Color roadHiliteColor -> s
    int r -> t
    int g -> u
    int b -> v
    int a -> w
com.gutabi.capsloc.ui.paint.FontStyle -> com.gutabi.a.c.a.c:
    com.gutabi.capsloc.ui.paint.FontStyle PLAIN -> a
    com.gutabi.capsloc.ui.paint.FontStyle[] ENUM$VALUES -> b
    com.gutabi.capsloc.ui.paint.FontStyle[] values() -> values
    com.gutabi.capsloc.ui.paint.FontStyle valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.ui.paint.Join -> com.gutabi.a.c.a.d:
    com.gutabi.capsloc.ui.paint.Join BEVEL -> a
    com.gutabi.capsloc.ui.paint.Join MITER -> b
    com.gutabi.capsloc.ui.paint.Join ROUND -> c
    com.gutabi.capsloc.ui.paint.Join[] ENUM$VALUES -> d
    com.gutabi.capsloc.ui.paint.Join[] values() -> values
    com.gutabi.capsloc.ui.paint.Join valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.ui.paint.RenderingContext -> com.gutabi.a.c.a.e:
    com.gutabi.capsloc.world.WorldCamera cam -> g
    void setAlpha(double) -> c
    void setStroke(double,com.gutabi.capsloc.ui.paint.Cap,com.gutabi.capsloc.ui.paint.Join) -> a
    void setColor(com.gutabi.capsloc.ui.paint.Color) -> b
    void setXORMode(com.gutabi.capsloc.ui.paint.Color) -> a
    void clearXORMode() -> b
    void setFont(com.gutabi.capsloc.Resource,com.gutabi.capsloc.ui.paint.FontStyle,int) -> a
    void scale(double) -> b
    void translate(double,double) -> a
    void clip(com.gutabi.capsloc.geom.AABB) -> c
    void pushTransform() -> c
    void popTransform() -> d
    void pushClip() -> e
    void popClip() -> f
    void rotate(double) -> a
    void paintString(double,double,double,java.lang.String) -> a
    void paintImage(com.gutabi.capsloc.ui.Image,double,double,double,double,double,int,int,int,int) -> a
    void paintImage(com.gutabi.capsloc.ui.Image,int,int,int,int,int,int,int,int) -> a
    void dispose() -> a
    void drawAABB(com.gutabi.capsloc.geom.AABB) -> a
    void paintAABB(com.gutabi.capsloc.geom.AABB) -> b
    void drawAABB(com.gutabi.capsloc.geom.MutableAABB) -> a
    void drawLine(com.gutabi.capsloc.geom.Line) -> a
    void paintCircle(com.gutabi.capsloc.geom.Circle) -> a
    void setAntialiasing() -> g
    void clearAntialiasing() -> h
com.gutabi.capsloc.world.CarMap -> com.gutabi.a.d.a:
    com.gutabi.capsloc.world.World world -> a
    java.util.List cars -> b
    com.gutabi.capsloc.world.cars.Car redCar -> c
    java.util.List toBeRemoved -> d
    boolean $assertionsDisabled -> e
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum -> f
    void addCar(com.gutabi.capsloc.world.cars.Car) -> a
    com.gutabi.capsloc.world.cars.Car carHitTest(com.gutabi.capsloc.math.Point) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    boolean preStep(double) -> a
    void postStep(double) -> b
    void findDeadlockCycles(double) -> c
    com.gutabi.capsloc.world.cars.DrivingEvent findDeadlockEvent(com.gutabi.capsloc.world.cars.AutonomousDriver) -> a
    com.gutabi.capsloc.world.cars.AutonomousDriver findDeadlockCause(com.gutabi.capsloc.world.cars.AutonomousDriver) -> b
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum() -> a
com.gutabi.capsloc.world.GrassMap -> com.gutabi.a.d.b:
    java.util.List grass -> a
    java.util.List toRemove -> b
    void addGrass(com.gutabi.capsloc.world.sprites.AnimatedGrass) -> a
    void mowGrass(java.lang.Object) -> a
    void preStart() -> a
    boolean step(double) -> a
    void paintScene(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.world.Quadrant -> com.gutabi.a.d.c:
    com.gutabi.capsloc.world.QuadrantMap map -> a
    int r -> b
    int c -> c
    boolean active -> d
    com.gutabi.capsloc.world.Quadrant up -> e
    com.gutabi.capsloc.world.Quadrant left -> f
    com.gutabi.capsloc.world.Quadrant right -> g
    com.gutabi.capsloc.world.Quadrant down -> h
    com.gutabi.capsloc.world.Quadrant rightDown -> i
    com.gutabi.capsloc.world.GrassMap grassMap -> j
    boolean grid -> k
    com.gutabi.capsloc.geom.AABB aabb -> l
    double gridSpacing -> m
    void init() -> a
    void preStart() -> b
    boolean step(double) -> a
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintScene(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
com.gutabi.capsloc.world.QuadrantMap -> com.gutabi.a.d.d:
    com.gutabi.capsloc.geom.AABB worldAABB -> a
    int quadrantCols -> b
    int quadrantRows -> c
    int[][] ini -> d
    com.gutabi.capsloc.world.Quadrant[][] quadrants -> g
    com.gutabi.capsloc.ui.Image quadrantGrass -> e
    com.gutabi.capsloc.ui.paint.RenderingContext ctxt -> f
    com.gutabi.capsloc.world.Quadrant[][] initQuadrants(int[][]) -> a
    void panelPostDisplay(com.gutabi.capsloc.world.WorldCamera) -> a
    boolean contains(java.lang.Object) -> a
    void mowGrass(java.lang.Object) -> b
    void preStart() -> a
    boolean step(double) -> a
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintScene(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
com.gutabi.capsloc.world.Stats -> com.gutabi.a.d.e:
    com.gutabi.capsloc.world.World world -> a
com.gutabi.capsloc.world.Stroke -> com.gutabi.a.d.f:
    double STROKE_RADIUS -> a
    com.gutabi.capsloc.world.World world -> b
    java.util.List cs -> f
    boolean finished -> g
    java.util.List caps -> c
    com.gutabi.capsloc.geom.CapsuleSequence seq -> d
    com.gutabi.capsloc.geom.AABB aabb -> h
    boolean $assertionsDisabled -> e
    int[] $SWITCH_TABLE$com$gutabi$capsloc$geom$SweepEventType -> i
    void add(com.gutabi.capsloc.math.Point) -> a
    com.gutabi.capsloc.math.Point get(int) -> a
    com.gutabi.capsloc.geom.Circle getCircle(int) -> b
    int size() -> a
    void finish() -> b
    java.util.Set processNewStroke(boolean) -> a
    java.util.List events(boolean) -> b
    java.util.List selfEvents(com.gutabi.capsloc.geom.MutableCapsuleSequence,int,java.util.List) -> a
    void computeAABB() -> d
    int[] $SWITCH_TABLE$com$gutabi$capsloc$geom$SweepEventType() -> c
com.gutabi.capsloc.world.World -> com.gutabi.a.d.g:
    com.gutabi.capsloc.world.WorldCamera worldCamera -> k
    java.util.concurrent.atomic.AtomicBoolean simThreadTrigger -> l
    java.lang.Thread simThread -> m
    com.gutabi.capsloc.world.WorldBackground background -> n
    com.gutabi.capsloc.world.QuadrantMap quadrantMap -> o
    com.gutabi.capsloc.world.graph.Graph graph -> p
    com.gutabi.capsloc.world.CarMap carMap -> q
    com.gutabi.capsloc.world.Stats stats -> r
    com.gutabi.capsloc.ui.Shimmer shimmer -> s
    com.gutabi.capsloc.math.Point lastPressedWorldPoint -> t
    com.gutabi.capsloc.math.Point lastDraggedWorldPoint -> u
    com.gutabi.capsloc.math.Point penDraggedWorldPoint -> v
    boolean lastDraggedWorldPointWasNull -> w
    com.gutabi.capsloc.math.Point lastMovedOrDraggedWorldPoint -> x
    com.gutabi.capsloc.geom.MutableAABB shimmerTmp -> y
    void preStart() -> k
    boolean integrate(double) -> a
    boolean preStep() -> b
    boolean step() -> l
    void postStep() -> c
    java.util.Set addFixture(com.gutabi.capsloc.world.graph.Fixture) -> a
    java.util.Set addIntersection(com.gutabi.capsloc.world.graph.Intersection) -> a
    com.gutabi.capsloc.world.graph.Intersection splitRoad(com.gutabi.capsloc.world.graph.RoadPosition) -> a
    java.util.Set createRoad(com.gutabi.capsloc.world.graph.Vertex,com.gutabi.capsloc.world.graph.Vertex,java.util.List) -> a
    com.gutabi.capsloc.world.graph.BypassBoard createBypassBoard(com.gutabi.capsloc.math.Point,char[][]) -> a
    void pressed(com.gutabi.capsloc.ui.InputEvent) -> a
    void released(com.gutabi.capsloc.ui.InputEvent) -> b
    void canceled(com.gutabi.capsloc.ui.InputEvent) -> c
    void dragged(com.gutabi.capsloc.ui.InputEvent) -> d
    void postDisplay(int,int) -> b
    void render() -> h
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.world.WorldBackground -> com.gutabi.a.d.h:
    com.gutabi.capsloc.world.WorldBackground$RenderMethod method -> a
    com.gutabi.capsloc.world.World world -> b
    com.gutabi.capsloc.ui.Image img -> e
    int panelWidth -> c
    int panelHeight -> d
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod -> f
    void panelPostDisplay(int,int) -> a
    void render() -> a
    void paint_pixels(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paint_worldCoords(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod() -> b
com.gutabi.capsloc.world.WorldBackground$RenderMethod -> com.gutabi.a.d.i:
    com.gutabi.capsloc.world.WorldBackground$RenderMethod MONOLITHIC -> a
    com.gutabi.capsloc.world.WorldBackground$RenderMethod DYNAMIC -> b
    com.gutabi.capsloc.world.WorldBackground$RenderMethod RENDERED_GRAPH -> c
    com.gutabi.capsloc.world.WorldBackground$RenderMethod RENDERED_ROADS -> d
    com.gutabi.capsloc.world.WorldBackground$RenderMethod RENDERED_ROADS_VERTICES -> e
    com.gutabi.capsloc.world.WorldBackground$RenderMethod RENDERED_ROADS_VERTICES_BOARDS -> f
    com.gutabi.capsloc.world.WorldBackground$RenderMethod[] ENUM$VALUES -> g
    com.gutabi.capsloc.world.WorldBackground$RenderMethod[] values() -> values
    com.gutabi.capsloc.world.WorldBackground$RenderMethod valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.WorldCamera -> com.gutabi.a.d.j:
    double pixelsPerMeter -> a
    double origPixelsPerMeter -> b
    com.gutabi.capsloc.geom.MutableAABB worldViewport -> c
    com.gutabi.capsloc.geom.AABB origWorldViewport -> d
    com.gutabi.capsloc.geom.AABB panelAABB -> e
    void zoomAbsolute(double) -> a
    void panAbsolute(double,double) -> a
com.gutabi.capsloc.world.WorldPanel -> com.gutabi.a.d.k:
    void postDisplay(int,int) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.world.cars.AutonomousCar -> com.gutabi.a.d.a.a:
    com.gutabi.capsloc.world.graph.Fixture source -> a
    boolean $assertionsDisabled -> b
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum -> c
    com.gutabi.capsloc.world.cars.AutonomousCar createCar(com.gutabi.capsloc.world.World,com.gutabi.capsloc.world.sprites.CarSheet$CarType,com.gutabi.capsloc.world.graph.Fixture,int) -> a
    void computeStartingProperties() -> a
    boolean preStep(double) -> a
    boolean postStep(double) -> c
    void computeDynamicPropertiesMovingAndMore(double) -> b
    void skid() -> b
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum() -> e
com.gutabi.capsloc.world.cars.AutonomousDriver -> com.gutabi.a.d.a.b:
    double carProximityLookahead -> a
    double vertexArrivalLookahead -> b
    com.gutabi.capsloc.world.cars.VertexArrivalEvent curVertexArrivalEvent -> c
    com.gutabi.capsloc.world.cars.CarProximityEvent curCarProximityEvent -> d
    java.util.List vertexDepartureQueue -> e
    double decelTime -> f
    double stoppedTime -> g
    boolean deadlocked -> h
    boolean $assertionsDisabled -> i
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum -> v
    void computeStartingProperties() -> a
    void cleanupVertexDepartureQueue() -> d
    void clear() -> b
    void preStep(double) -> a
    void postStep(double) -> b
    com.gutabi.capsloc.world.cars.CarProximityEvent findNewCarProximityEvent() -> e
    com.gutabi.capsloc.world.cars.VertexArrivalEvent findNewVertexArrivalEvent() -> f
    boolean handleDrivingEvent(com.gutabi.capsloc.world.cars.DrivingEvent,double) -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum() -> c
com.gutabi.capsloc.world.cars.AutonomousEngine -> com.gutabi.a.d.a.c:
    boolean $assertionsDisabled -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum -> o
    void preStep(double) -> a
    void updateFriction() -> b
    void updateDrive() -> c
    void turn() -> d
    void updateBrake(double) -> b
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum() -> a
com.gutabi.capsloc.world.cars.Car -> com.gutabi.a.d.a.d:
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type -> e
    com.gutabi.capsloc.world.cars.CarStateEnum state -> f
    double startingTime -> g
    com.gutabi.capsloc.world.cars.Driver driver -> h
    com.gutabi.capsloc.world.cars.Engine engine -> i
    int id -> j
    boolean atleastPartiallyOnRoad -> k
    boolean inMerger -> l
    com.gutabi.capsloc.math.Point toolOrigCenter -> m
    com.gutabi.capsloc.geom.MutableOBB toolOrigShape -> n
    boolean destroyed -> o
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite sprite -> p
    int sheetIndex -> q
    com.gutabi.capsloc.geom.GeometryPath path -> r
    int carIDCounter -> s
    double BRAKE_SIZE -> t
    double BRAKE_LOCALX -> u
    double BRAKE_LOCALY -> v
    double CAR_BRAKE1X -> w
    double CAR_BRAKE1Y -> x
    double CAR_BRAKE2X -> y
    double CAR_BRAKE2Y -> z
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum -> a
    void computeCtorProperties(int) -> a
    void setTransform(com.gutabi.capsloc.math.Point,double) -> a
    void destroy() -> f
    com.gutabi.capsloc.Entity hitTest(com.gutabi.capsloc.math.Point) -> a
    boolean isUserDeleteable() -> c
    void preStart() -> d
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintImage(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
    void paintRect(com.gutabi.capsloc.ui.paint.RenderingContext) -> c
    void paintBrakes(com.gutabi.capsloc.ui.paint.RenderingContext) -> d
    void paintID(com.gutabi.capsloc.ui.paint.RenderingContext) -> e
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum() -> g
com.gutabi.capsloc.world.cars.CarProximityEvent -> com.gutabi.a.d.a.e:
    com.gutabi.capsloc.world.cars.AutonomousDriver d -> a
    com.gutabi.capsloc.world.cars.AutonomousDriver otherDriver -> b
    int hash -> c
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
com.gutabi.capsloc.world.cars.CarStateEnum -> com.gutabi.a.d.a.f:
    com.gutabi.capsloc.world.cars.CarStateEnum DRIVING -> a
    com.gutabi.capsloc.world.cars.CarStateEnum BRAKING -> b
    com.gutabi.capsloc.world.cars.CarStateEnum CRASHED -> c
    com.gutabi.capsloc.world.cars.CarStateEnum SKIDDED -> d
    com.gutabi.capsloc.world.cars.CarStateEnum SINKED -> e
    com.gutabi.capsloc.world.cars.CarStateEnum IDLE -> f
    com.gutabi.capsloc.world.cars.CarStateEnum DRAGGING -> g
    com.gutabi.capsloc.world.cars.CarStateEnum COASTING_FORWARD -> h
    com.gutabi.capsloc.world.cars.CarStateEnum COASTING_BACKWARD -> i
    com.gutabi.capsloc.world.cars.CarStateEnum[] ENUM$VALUES -> j
    com.gutabi.capsloc.world.cars.CarStateEnum[] values() -> values
    com.gutabi.capsloc.world.cars.CarStateEnum valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.cars.Driver -> com.gutabi.a.d.a.g:
    com.gutabi.capsloc.world.cars.Car c -> j
    com.gutabi.capsloc.world.graph.GraphPosition startGP -> k
    com.gutabi.capsloc.world.graph.Side startSide -> l
    com.gutabi.capsloc.world.graph.GraphPositionPath overallPath -> m
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition overallPos -> n
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition prevOverallPos -> o
    com.gutabi.capsloc.math.Point goalPoint -> p
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition toolOrigOverallPos -> q
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition toolOrigExitingVertexPos -> r
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition toolLastExitingVertexPos -> s
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition toolCoastingGoal -> t
    boolean $assertionsDisabled -> u
    void setOverallPos(com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> a
com.gutabi.capsloc.world.cars.DrivingEvent -> com.gutabi.a.d.a.h:
com.gutabi.capsloc.world.cars.Engine -> com.gutabi.a.d.a.i:
    double maxSpeed -> b
    double maxRadsPerMeter -> c
    double maxAcceleration -> d
    double frictionForwardImpulseCoefficient -> e
    double frictionLateralImpulseCoefficient -> f
    double frictionAngularImpulseCoefficient -> g
    double driveForwardImpulseCoefficient -> h
    double driveLateralImpulseCoefficient -> i
    double brakeForwardImpulseCoefficient -> j
    double brakeLateralImpulseCoefficient -> k
    double turnAngularImpulseCoefficient -> l
    com.gutabi.capsloc.world.World world -> m
    com.gutabi.capsloc.world.cars.Car c -> n
    void preStep(double) -> a
com.gutabi.capsloc.world.cars.VertexArrivalEvent -> com.gutabi.a.d.a.j:
    com.gutabi.capsloc.world.cars.Driver d -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition entrancePosition -> b
    com.gutabi.capsloc.world.graph.StopSign sign -> c
    int hash -> g
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
com.gutabi.capsloc.world.cars.VertexEvent -> com.gutabi.a.d.a.k:
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition vertexPosition -> d
    com.gutabi.capsloc.world.graph.Vertex v -> e
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition carPastExitPosition -> f
com.gutabi.capsloc.world.cars.VertexSpawnEvent -> com.gutabi.a.d.a.l:
com.gutabi.capsloc.world.graph.Axis -> com.gutabi.a.d.b.a:
    com.gutabi.capsloc.world.graph.Axis TOPBOTTOM -> a
    com.gutabi.capsloc.world.graph.Axis LEFTRIGHT -> b
    boolean $assertionsDisabled -> c
    com.gutabi.capsloc.world.graph.Axis[] ENUM$VALUES -> d
    com.gutabi.capsloc.world.graph.Axis[] values() -> values
    com.gutabi.capsloc.world.graph.Axis valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.graph.BorderStud -> com.gutabi.a.d.b.b:
    com.gutabi.capsloc.world.graph.Fixture f -> a
    boolean $assertionsDisabled -> b
    boolean across(com.gutabi.capsloc.world.graph.BorderStud) -> a
    boolean withinRowRange(int) -> a
    boolean withinColRange(int) -> b
com.gutabi.capsloc.world.graph.BypassBoard -> com.gutabi.a.d.b.c:
    com.gutabi.capsloc.ui.paint.Color BOARDCOLOR -> a
    com.gutabi.capsloc.world.World world -> b
    com.gutabi.capsloc.math.Point center -> c
    char[][] ini -> d
    java.util.List studs -> e
    java.util.List perimeterSegments -> f
    java.util.List neg -> g
    int originRow -> h
    int originCol -> i
    int rowCount -> j
    int colCount -> k
    com.gutabi.capsloc.math.Point ul -> l
    com.gutabi.capsloc.geom.AABB allStudsAABB -> m
    com.gutabi.capsloc.geom.AABB gridAABB -> n
    com.gutabi.capsloc.geom.AABB gridFudgeAABB -> o
    com.gutabi.capsloc.geom.AABB backAABB -> p
    com.gutabi.capsloc.geom.AABB zoomingAABB -> q
    int jStudCount -> r
    com.gutabi.capsloc.world.graph.BorderStud[] jStuds -> s
    int kStudCount -> t
    com.gutabi.capsloc.world.graph.BorderStud[] kStuds -> u
    com.gutabi.capsloc.world.graph.BorderStud yStud -> v
    com.gutabi.capsloc.world.graph.Vertex exitVertex -> w
    java.util.Map rowTracks -> x
    java.util.Map colTracks -> y
    java.util.Map rowPaths -> E
    java.util.Map colPaths -> F
    com.gutabi.capsloc.ui.Image img -> z
    com.gutabi.capsloc.geom.MutableAABB test -> A
    com.gutabi.capsloc.geom.MutableAABB testFloor -> B
    com.gutabi.capsloc.geom.MutableAABB testCeil -> C
    boolean $assertionsDisabled -> D
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Side -> G
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Axis -> H
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod -> I
    void addExitRoad(com.gutabi.capsloc.world.graph.BorderStud) -> a
    void addExitRoadToTrack(java.util.List,com.gutabi.capsloc.world.graph.BorderStud) -> a
    void addJointRoad(com.gutabi.capsloc.world.graph.BorderStud[]) -> a
    void exitTrackToPath(com.gutabi.capsloc.world.graph.BorderStud) -> b
    void jointTracksToPath(com.gutabi.capsloc.world.graph.BorderStud,com.gutabi.capsloc.world.graph.BorderStud) -> a
    void jointTracksToPath(com.gutabi.capsloc.world.graph.BorderStud,com.gutabi.capsloc.world.graph.BorderStud,com.gutabi.capsloc.world.graph.BorderStud,com.gutabi.capsloc.world.graph.BorderStud) -> a
    void removePerimeterSegment(com.gutabi.capsloc.geom.Line) -> a
    void preStart() -> d
    boolean preStep(double) -> a
    boolean postStep(double) -> c
    com.gutabi.capsloc.world.graph.GraphPositionPath getPath(com.gutabi.capsloc.world.graph.Axis,int) -> a
    com.gutabi.capsloc.math.Point point(double,double) -> a
    com.gutabi.capsloc.world.graph.BypassBoardPosition position(com.gutabi.capsloc.math.Point) -> a
    boolean withinGrid(com.gutabi.capsloc.world.cars.Car,double,com.gutabi.capsloc.math.Point) -> a
    boolean floorAndCeilWithinGrid(com.gutabi.capsloc.world.cars.Car) -> a
    boolean enteringBoard(com.gutabi.capsloc.world.graph.BypassBoardPosition,com.gutabi.capsloc.world.graph.BypassBoardPosition) -> a
    double carInGridFraction(com.gutabi.capsloc.world.cars.Car) -> b
    boolean isUserDeleteable() -> c
    void render() -> a
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintStuds(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Side() -> b
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Axis() -> e
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod() -> f
com.gutabi.capsloc.world.graph.BypassBoardPosition -> com.gutabi.a.d.b.d:
    double rowCombo -> a
    double colCombo -> b
    int rowIndex -> c
    int colIndex -> d
    double rowParam -> e
    double colParam -> f
    boolean bound -> g
    int hash -> k
    boolean $assertionsDisabled -> h
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isBound() -> a
    com.gutabi.capsloc.world.graph.GraphPosition approachNeighbor(com.gutabi.capsloc.world.graph.GraphPosition,double) -> a
    double goalGPPPCombo(int,double,boolean,com.gutabi.capsloc.world.graph.GraphPosition,com.gutabi.capsloc.world.graph.GraphPositionPath,com.gutabi.capsloc.world.graph.GraphPositionPathPosition,double) -> a
com.gutabi.capsloc.world.graph.BypassStud -> com.gutabi.a.d.b.e:
    com.gutabi.capsloc.world.World world -> c
    com.gutabi.capsloc.world.graph.BypassBoard board -> d
    int row -> e
    int col -> f
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite sprite -> g
    com.gutabi.capsloc.geom.AABB aabb -> h
    java.lang.String toString() -> toString
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.world.graph.Direction -> com.gutabi.a.d.b.f:
    com.gutabi.capsloc.world.graph.Direction STARTTOEND -> a
    com.gutabi.capsloc.world.graph.Direction ENDTOSTART -> b
    boolean $assertionsDisabled -> c
    com.gutabi.capsloc.world.graph.Direction[] ENUM$VALUES -> d
    com.gutabi.capsloc.world.graph.Direction[] values() -> values
    com.gutabi.capsloc.world.graph.Direction valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.graph.Edge -> com.gutabi.a.d.b.g:
    int id -> a
    int pointCount() -> a
    double getTotalLength(com.gutabi.capsloc.world.graph.Vertex,com.gutabi.capsloc.world.graph.Vertex) -> a
    com.gutabi.capsloc.world.graph.Direction getDirection(com.gutabi.capsloc.world.graph.Axis) -> a
    com.gutabi.capsloc.world.graph.Vertex getReferenceVertex(com.gutabi.capsloc.world.graph.Axis) -> b
    com.gutabi.capsloc.world.graph.Vertex getOtherVertex(com.gutabi.capsloc.world.graph.Axis) -> c
    com.gutabi.capsloc.world.graph.GraphPosition travelFromReferenceVertex(com.gutabi.capsloc.world.graph.Axis,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelFromOtherVertex(com.gutabi.capsloc.world.graph.Axis,double) -> b
com.gutabi.capsloc.world.graph.EdgePosition -> com.gutabi.a.d.b.h:
    com.gutabi.capsloc.world.graph.Axis axis -> a
    boolean $assertionsDisabled -> b
    com.gutabi.capsloc.world.graph.GraphPosition travelToReferenceVertex(com.gutabi.capsloc.world.graph.Axis,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelToOtherVertex(com.gutabi.capsloc.world.graph.Axis,double) -> b
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundTowardReferenceVertex() -> b
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundTowardOtherVertex() -> c
    int getIndex() -> d
    double getParam() -> e
    double getCombo() -> f
    com.gutabi.capsloc.world.graph.GraphPosition approachNeighbor(com.gutabi.capsloc.world.graph.GraphPosition,double) -> a
    double goalGPPPCombo(int,double,boolean,com.gutabi.capsloc.world.graph.GraphPosition,com.gutabi.capsloc.world.graph.GraphPositionPath,com.gutabi.capsloc.world.graph.GraphPositionPathPosition,double) -> a
com.gutabi.capsloc.world.graph.Fixture -> com.gutabi.a.d.b.i:
    double SPAWN_FREQUENCY_SECONDS -> a
    com.gutabi.capsloc.world.graph.Axis a -> b
    com.gutabi.capsloc.world.graph.Side facingSide -> v
    com.gutabi.capsloc.world.graph.FixtureType type -> w
    com.gutabi.capsloc.world.graph.Fixture match -> c
    com.gutabi.capsloc.world.graph.GraphPositionPath shortestPathToMatch -> d
    double lastSpawnTime -> e
    int outstandingCars -> f
    com.gutabi.capsloc.ui.Image img -> g
    com.gutabi.capsloc.geom.AABB intersection -> h
    com.gutabi.capsloc.world.cars.AutonomousCar waitingCar -> i
    boolean $assertionsDisabled -> j
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod -> x
    void setFacingSide(com.gutabi.capsloc.world.graph.Side) -> a
    com.gutabi.capsloc.world.graph.Side getFacingSide() -> a
    boolean supportsStopSigns() -> b
    boolean isUserDeleteable() -> c
    void preStart() -> d
    boolean preStep(double) -> a
    boolean postStep(double) -> c
    com.gutabi.capsloc.world.graph.GraphPositionPath getShortestPathToMatch() -> e
    void spawnNewCar(double) -> b
    boolean active(double) -> d
    com.gutabi.capsloc.world.cars.AutonomousCar createNewCar() -> i
    void render() -> f
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintScene(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod() -> g
com.gutabi.capsloc.world.graph.FixtureType -> com.gutabi.a.d.b.j:
    com.gutabi.capsloc.world.graph.FixtureType SOURCE -> a
    com.gutabi.capsloc.world.graph.FixtureType SINK -> b
    boolean $assertionsDisabled -> c
    com.gutabi.capsloc.world.graph.FixtureType[] ENUM$VALUES -> d
    com.gutabi.capsloc.world.graph.FixtureType[] values() -> values
    com.gutabi.capsloc.world.graph.FixtureType valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.graph.GPPAccumulator -> com.gutabi.a.d.b.k:
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition par -> a
    com.gutabi.capsloc.math.Point p -> b
    int closestIndex -> c
    double closestParam -> d
    double closestDistance -> e
    boolean $assertionsDisabled -> f
    void reset(com.gutabi.capsloc.math.Point) -> a
    void apply(com.gutabi.capsloc.world.graph.GraphPositionPathPosition,com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition result() -> a
com.gutabi.capsloc.world.graph.Graph -> com.gutabi.a.d.b.l:
    com.gutabi.capsloc.world.World world -> a
    java.util.List vertices -> b
    java.util.List roads -> c
    java.util.List mergers -> d
    java.util.List boards -> e
    com.gutabi.capsloc.world.graph.GraphPositionPathFactory pathFactory -> f
    java.util.List paths -> g
    com.gutabi.capsloc.geom.AABB aabb -> h
    com.gutabi.capsloc.ui.Image img -> i
    com.gutabi.capsloc.world.graph.Vertex[] vertexIDs -> j
    double[][] distances -> k
    com.gutabi.capsloc.world.graph.Vertex[][] nextHighest -> l
    boolean $assertionsDisabled -> m
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Direction -> n
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod -> o
    void preStart() -> a
    boolean preStep(double) -> a
    void postStep(double) -> b
    java.util.Set addVertexTop(com.gutabi.capsloc.world.graph.Vertex) -> a
    java.util.Set createRoadTop(com.gutabi.capsloc.world.graph.Road) -> a
    void insertBypassBoardTop(com.gutabi.capsloc.world.graph.BypassBoard) -> a
    boolean automaticMergeOrDestroy(com.gutabi.capsloc.world.graph.Vertex) -> b
    boolean forceMergeOrDestroy(com.gutabi.capsloc.world.graph.Vertex) -> c
    void addVertex(com.gutabi.capsloc.world.graph.Vertex) -> d
    void createRoad(com.gutabi.capsloc.world.graph.Road,int) -> a
    void destroyVertex(com.gutabi.capsloc.world.graph.Vertex) -> e
    void destroyRoad(com.gutabi.capsloc.world.graph.Road) -> b
    void computeAABB() -> e
    com.gutabi.capsloc.world.graph.Vertex shortestPathChoice(com.gutabi.capsloc.world.graph.Vertex,com.gutabi.capsloc.world.graph.Vertex) -> a
    double distanceBetweenVertices(com.gutabi.capsloc.world.graph.Vertex,com.gutabi.capsloc.world.graph.Vertex) -> b
    com.gutabi.capsloc.Entity pureGraphIntersectCircle(com.gutabi.capsloc.geom.Circle) -> a
    com.gutabi.capsloc.Entity pureGraphIntersectCapsule(com.gutabi.capsloc.geom.Capsule) -> a
    com.gutabi.capsloc.world.graph.RoadPosition findClosestRoadPosition(com.gutabi.capsloc.math.Point,double) -> a
    com.gutabi.capsloc.world.graph.Intersection split(com.gutabi.capsloc.world.graph.RoadPosition) -> a
    void refreshVertexIDs() -> f
    void refreshRoadIDs() -> g
    void initializeMatrices() -> h
    void merge(com.gutabi.capsloc.world.graph.Vertex) -> f
    void render() -> b
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintScene(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
    void paintIDs(com.gutabi.capsloc.ui.paint.RenderingContext) -> c
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Direction() -> c
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod() -> d
com.gutabi.capsloc.world.graph.GraphPosition -> com.gutabi.a.d.b.m:
    com.gutabi.capsloc.math.Point p -> i
    com.gutabi.capsloc.Entity entity -> j
    boolean isBound() -> a
    com.gutabi.capsloc.world.graph.GraphPosition approachNeighbor(com.gutabi.capsloc.world.graph.GraphPosition,double) -> a
    double goalGPPPCombo(int,double,boolean,com.gutabi.capsloc.world.graph.GraphPosition,com.gutabi.capsloc.world.graph.GraphPositionPath,com.gutabi.capsloc.world.graph.GraphPositionPathPosition,double) -> a
com.gutabi.capsloc.world.graph.GraphPositionPath -> com.gutabi.a.d.b.n:
    java.util.List poss -> o
    int size -> a
    com.gutabi.capsloc.world.graph.GraphPosition start -> b
    com.gutabi.capsloc.world.graph.GraphPosition end -> c
    double[] cumulativeDistancesFromStart -> d
    double totalLength -> e
    boolean hasLoop -> f
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition startPos -> g
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition endPos -> h
    java.util.Map verticesMap -> i
    java.util.Map edgesMap -> j
    java.util.Map axesMap -> k
    java.util.List borderPositions -> p
    java.util.List currentDrivers -> l
    java.util.Map sharedEdgesMap -> m
    int hash -> q
    java.util.Map hitMap -> r
    boolean $assertionsDisabled -> n
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    com.gutabi.capsloc.world.graph.GraphPosition get(int) -> a
    com.gutabi.capsloc.world.cars.VertexArrivalEvent vertexArrivalTest(com.gutabi.capsloc.world.cars.AutonomousDriver,double) -> a
    int nextVertexIndex(int,double) -> a
    int prevVertexIndex(int,double) -> b
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition findGraphPositionPathPosition(com.gutabi.capsloc.world.graph.GraphPosition,double) -> a
    void precomputeHitTestData() -> a
    java.util.Map precomputeHitTestDataNew() -> c
    void clearHitTestData() -> b
    com.gutabi.capsloc.world.cars.AutonomousDriver driverProximityTest(com.gutabi.capsloc.world.graph.GraphPositionPathPosition,double) -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition hitTest(com.gutabi.capsloc.world.cars.Driver,com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> a
    com.gutabi.capsloc.Entity pureGraphIntersectOBB(com.gutabi.capsloc.geom.MutableOBB,com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> a
com.gutabi.capsloc.world.graph.GraphPositionPathFactory -> com.gutabi.a.d.b.o:
    com.gutabi.capsloc.world.graph.Graph graph -> a
    boolean $assertionsDisabled -> b
    com.gutabi.capsloc.world.graph.GraphPositionPath createShortestVertexPath(java.util.List) -> a
    void calculateShortestVertexPath(java.util.List,com.gutabi.capsloc.world.graph.VertexPosition,com.gutabi.capsloc.world.graph.VertexPosition) -> a
    void fillin(java.util.List,com.gutabi.capsloc.world.graph.VertexPosition,com.gutabi.capsloc.world.graph.VertexPosition,com.gutabi.capsloc.world.graph.Edge,int) -> a
com.gutabi.capsloc.world.graph.GraphPositionPathPosition -> com.gutabi.a.d.b.p:
    com.gutabi.capsloc.world.graph.GraphPositionPath path -> a
    int index -> b
    double param -> c
    double combo -> d
    boolean bound -> e
    com.gutabi.capsloc.math.Point p -> f
    com.gutabi.capsloc.world.graph.GraphPosition gp -> g
    double lengthToStartOfPath -> h
    double lengthToEndOfPath -> i
    double angle -> j
    int hash -> o
    com.gutabi.capsloc.geom.MutableOBB mao -> k
    com.gutabi.capsloc.geom.MutableOBB mbo -> l
    com.gutabi.capsloc.geom.MutableSweptOBB swept -> m
    boolean $assertionsDisabled -> n
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    boolean isEndOfPath() -> a
    com.gutabi.capsloc.math.Point pathVector() -> b
    double lengthTo(com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition travel(double,boolean) -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition travelByVertex(double,boolean) -> b
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition travelByBound(double,boolean,com.gutabi.capsloc.world.graph.GPPAccumulator) -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition travelWithinBound(com.gutabi.capsloc.world.graph.GraphPosition,double,boolean,com.gutabi.capsloc.world.graph.GPPAccumulator) -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition travelForward(double) -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition travelBackward(double) -> b
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition nextBound() -> c
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition prevBound() -> d
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition floor() -> e
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition ceil() -> f
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition floor(double) -> c
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition ceil(double) -> d
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition round(double) -> e
    int prevVertexIndex() -> g
    int nextVertexIndex() -> h
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition prevVertexPosition() -> i
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition nextVertexPosition() -> j
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition forwardSearch(com.gutabi.capsloc.math.Point,double) -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition backwardSearch(com.gutabi.capsloc.math.Point,double) -> b
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition generalSearch(com.gutabi.capsloc.math.Point,double) -> c
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition furthestAllowablePosition(com.gutabi.capsloc.world.cars.Car,com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition furthestAllowablePositionForward(com.gutabi.capsloc.world.cars.Car,com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> b
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition furthestAllowablePositionBackward(com.gutabi.capsloc.world.cars.Car,com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> c
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition findFirstRightAngleForwardOrEnd(com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> b
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition findFirstRightAngleBackwardOrEnd(com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> c
    double firstCollisionParam(com.gutabi.capsloc.world.cars.Car,com.gutabi.capsloc.geom.SweptOBB) -> a
    double firstCollisionParam(com.gutabi.capsloc.world.cars.Car,com.gutabi.capsloc.geom.MutableSweptOBB) -> a
    int movesDistance(com.gutabi.capsloc.world.graph.GraphPositionPathPosition,com.gutabi.capsloc.world.cars.Car) -> a
com.gutabi.capsloc.world.graph.Intersection -> com.gutabi.a.d.b.q:
    boolean isUserDeleteable() -> c
    boolean supportsStopSigns() -> b
    void preStart() -> d
    boolean preStep(double) -> a
    boolean postStep(double) -> c
    void render() -> f
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintScene(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
com.gutabi.capsloc.world.graph.Merger -> com.gutabi.a.d.b.r:
    com.gutabi.capsloc.math.Point ul -> b
    com.gutabi.capsloc.world.graph.Fixture top -> c
    com.gutabi.capsloc.world.graph.Fixture left -> d
    com.gutabi.capsloc.world.graph.Fixture right -> e
    com.gutabi.capsloc.world.graph.Fixture bottom -> f
    com.gutabi.capsloc.world.graph.Direction leftRightDir -> i
    com.gutabi.capsloc.world.graph.Direction topBottomDir -> j
    double[] cumulativeLengthsFromTop -> k
    double[] cumulativeLengthsFromLeft -> l
    com.gutabi.capsloc.geom.AABB shape -> g
    com.gutabi.capsloc.geom.Line debugSkeletonTopBottomLine -> m
    com.gutabi.capsloc.geom.Line debugSkeletonLeftRightLine -> n
    boolean $assertionsDisabled -> h
    java.lang.String toString() -> toString
    int pointCount() -> a
    double getTotalLength(com.gutabi.capsloc.world.graph.Vertex,com.gutabi.capsloc.world.graph.Vertex) -> a
    com.gutabi.capsloc.world.graph.Vertex getReferenceVertex(com.gutabi.capsloc.world.graph.Axis) -> b
    com.gutabi.capsloc.world.graph.Vertex getOtherVertex(com.gutabi.capsloc.world.graph.Axis) -> c
    com.gutabi.capsloc.world.graph.Direction getDirection(com.gutabi.capsloc.world.graph.Axis) -> a
    void enterDistancesMatrix(double[][]) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelFromReferenceVertex(com.gutabi.capsloc.world.graph.Axis,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelFromOtherVertex(com.gutabi.capsloc.world.graph.Axis,double) -> b
    boolean isUserDeleteable() -> c
    void preStart() -> d
    boolean preStep(double) -> a
    boolean postStep(double) -> c
    com.gutabi.capsloc.math.Point get(int,com.gutabi.capsloc.world.graph.Axis) -> a
    double getLengthFromLeft(int) -> a
    double getLengthFromTop(int) -> b
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintSkeleton(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
com.gutabi.capsloc.world.graph.MergerPosition -> com.gutabi.a.d.b.s:
    com.gutabi.capsloc.world.graph.Merger m -> c
    int index -> d
    double param -> e
    double combo -> f
    double distanceToLeftOfMerger -> g
    double distanceToRightOfMerger -> h
    double distanceToTopOfMerger -> k
    double distanceToBottomOfMerger -> l
    boolean bound -> m
    int hash -> o
    boolean $assertionsDisabled -> n
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    boolean isBound() -> a
    int getIndex() -> d
    double getParam() -> e
    double getCombo() -> f
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundTowardOtherVertex() -> c
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundTowardReferenceVertex() -> b
    com.gutabi.capsloc.world.graph.GraphPosition travelToReferenceVertex(com.gutabi.capsloc.world.graph.Axis,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelToOtherVertex(com.gutabi.capsloc.world.graph.Axis,double) -> b
    com.gutabi.capsloc.world.graph.GraphPosition travelFromTop(com.gutabi.capsloc.world.graph.Merger,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelFromBottom(com.gutabi.capsloc.world.graph.Merger,double) -> b
    com.gutabi.capsloc.world.graph.GraphPosition travelFromLeft(com.gutabi.capsloc.world.graph.Merger,double) -> c
    com.gutabi.capsloc.world.graph.GraphPosition travelFromRight(com.gutabi.capsloc.world.graph.Merger,double) -> d
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundFromTop(com.gutabi.capsloc.world.graph.Merger) -> a
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundFromBottom(com.gutabi.capsloc.world.graph.Merger) -> b
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundFromLeft(com.gutabi.capsloc.world.graph.Merger) -> c
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundFromRight(com.gutabi.capsloc.world.graph.Merger) -> d
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundToLeft(com.gutabi.capsloc.world.graph.Merger,int,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundToRight(com.gutabi.capsloc.world.graph.Merger,int,double) -> b
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundToTop(com.gutabi.capsloc.world.graph.Merger,int,double) -> c
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundToBottom(com.gutabi.capsloc.world.graph.Merger,int,double) -> d
    com.gutabi.capsloc.world.graph.GraphPosition travelToLeft(com.gutabi.capsloc.world.graph.Merger,int,double,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelToRight(com.gutabi.capsloc.world.graph.Merger,int,double,double) -> b
    com.gutabi.capsloc.world.graph.GraphPosition travelToTop(com.gutabi.capsloc.world.graph.Merger,int,double,double) -> c
    com.gutabi.capsloc.world.graph.GraphPosition travelToBottom(com.gutabi.capsloc.world.graph.Merger,int,double,double) -> d
com.gutabi.capsloc.world.graph.RegularStud -> com.gutabi.a.d.b.t:
com.gutabi.capsloc.world.graph.Road -> com.gutabi.a.d.b.u:
    com.gutabi.capsloc.world.World world -> b
    com.gutabi.capsloc.world.graph.Vertex start -> c
    com.gutabi.capsloc.world.graph.Vertex end -> d
    java.util.List raw -> e
    com.gutabi.capsloc.world.graph.Direction direction -> l
    com.gutabi.capsloc.geom.CapsuleSequence seq -> m
    com.gutabi.capsloc.geom.Circle startBorderPoint -> n
    com.gutabi.capsloc.geom.Circle endBorderPoint -> o
    int startBorderIndex -> p
    int endBorderIndex -> q
    double[] cumulativeLengthsFromStart -> r
    double totalLength -> s
    boolean standalone -> t
    boolean loop -> u
    com.gutabi.capsloc.world.graph.StopSign startSign -> f
    com.gutabi.capsloc.world.graph.StopSign endSign -> g
    int hash -> v
    com.gutabi.capsloc.geom.CapsuleSequence shape -> h
    com.gutabi.capsloc.ui.Image img -> i
    com.gutabi.capsloc.geom.AABB intersection -> j
    com.gutabi.capsloc.geom.GeometryPath arrowPointerPath -> w
    boolean $assertionsDisabled -> k
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Direction -> x
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod -> y
    void destroy() -> b
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    boolean isStandAlone() -> e
    int pointCount() -> a
    int capsuleCount() -> f
    double getTotalLength(com.gutabi.capsloc.world.graph.Vertex,com.gutabi.capsloc.world.graph.Vertex) -> a
    com.gutabi.capsloc.math.Point getPoint(int) -> a
    com.gutabi.capsloc.math.Point getPoint(int,double) -> a
    com.gutabi.capsloc.math.Point getStartBorderPoint() -> g
    com.gutabi.capsloc.math.Point getEndBorderPoint() -> h
    void setDirection(com.gutabi.capsloc.world.graph.Axis,com.gutabi.capsloc.world.graph.Direction) -> a
    com.gutabi.capsloc.world.graph.Direction getDirection(com.gutabi.capsloc.world.graph.Axis) -> a
    com.gutabi.capsloc.world.graph.Vertex getReferenceVertex(com.gutabi.capsloc.world.graph.Axis) -> b
    com.gutabi.capsloc.world.graph.Vertex getOtherVertex(com.gutabi.capsloc.world.graph.Axis) -> c
    void preStart() -> d
    boolean preStep(double) -> a
    boolean postStep(double) -> c
    void enterDistancesMatrix(double[][]) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelFromReferenceVertex(com.gutabi.capsloc.world.graph.Axis,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelFromOtherVertex(com.gutabi.capsloc.world.graph.Axis,double) -> b
    com.gutabi.capsloc.world.graph.GraphPosition findSkeletonIntersection(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> a
    com.gutabi.capsloc.world.graph.RoadPosition findClosestRoadPosition(com.gutabi.capsloc.math.Point,double) -> a
    boolean isUserDeleteable() -> c
    double getLengthFromStart(int) -> b
    void computeProperties() -> i
    void computeCaps() -> m
    java.util.List removeDuplicates(java.util.List) -> a
    java.util.List removeColinear(java.util.List) -> b
    void computeBorders(java.util.List) -> c
    java.util.List adjustToBorders(java.util.List) -> d
    double startBorderCombo(com.gutabi.capsloc.world.graph.Vertex,java.util.List) -> a
    double endBorderCombo(com.gutabi.capsloc.world.graph.Vertex,java.util.List) -> b
    void computeLengths() -> n
    void render() -> j
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintPath_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> d
    void paintSkeleton(com.gutabi.capsloc.ui.paint.RenderingContext) -> e
    void paintBorders(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
    void paintDecorations(com.gutabi.capsloc.ui.paint.RenderingContext) -> c
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Direction() -> k
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod() -> l
com.gutabi.capsloc.world.graph.RoadPosition -> com.gutabi.a.d.b.v:
    com.gutabi.capsloc.world.graph.Road r -> c
    int index -> d
    double param -> e
    double combo -> f
    double angle -> g
    boolean bound -> h
    double lengthToStartOfRoad -> k
    double lengthToEndOfRoad -> l
    com.gutabi.capsloc.world.graph.StopSign sign -> m
    int hash -> o
    boolean $assertionsDisabled -> n
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    boolean isBound() -> a
    int getIndex() -> d
    double getParam() -> e
    double getCombo() -> f
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundTowardReferenceVertex() -> b
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundTowardOtherVertex() -> c
    com.gutabi.capsloc.world.graph.GraphPosition travelToReferenceVertex(com.gutabi.capsloc.world.graph.Axis,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelToOtherVertex(com.gutabi.capsloc.world.graph.Axis,double) -> b
    com.gutabi.capsloc.world.graph.GraphPosition travelFromStart(com.gutabi.capsloc.world.graph.Road,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelFromEnd(com.gutabi.capsloc.world.graph.Road,double) -> b
    com.gutabi.capsloc.world.graph.GraphPosition travelForward(com.gutabi.capsloc.world.graph.Road,int,double,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelBackward(com.gutabi.capsloc.world.graph.Road,int,double,double) -> b
    com.gutabi.capsloc.world.graph.RoadPosition nextBoundfromStart(com.gutabi.capsloc.world.graph.Road) -> a
    com.gutabi.capsloc.world.graph.RoadPosition nextBoundfromEnd(com.gutabi.capsloc.world.graph.Road) -> b
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundForward(com.gutabi.capsloc.world.graph.Road,int,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundBackward(com.gutabi.capsloc.world.graph.Road,int,double) -> b
    boolean check() -> g
com.gutabi.capsloc.world.graph.Side -> com.gutabi.a.d.b.w:
    com.gutabi.capsloc.world.graph.Side TOP -> a
    com.gutabi.capsloc.world.graph.Side LEFT -> b
    com.gutabi.capsloc.world.graph.Side RIGHT -> c
    com.gutabi.capsloc.world.graph.Side BOTTOM -> d
    boolean $assertionsDisabled -> e
    com.gutabi.capsloc.world.graph.Side[] ENUM$VALUES -> f
    com.gutabi.capsloc.world.graph.Side[] values() -> values
    com.gutabi.capsloc.world.graph.Side valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.graph.Side$1 -> com.gutabi.a.d.b.x:
com.gutabi.capsloc.world.graph.Side$2 -> com.gutabi.a.d.b.y:
com.gutabi.capsloc.world.graph.Side$3 -> com.gutabi.a.d.b.z:
com.gutabi.capsloc.world.graph.Side$4 -> com.gutabi.a.d.b.aa:
com.gutabi.capsloc.world.graph.StopSign -> com.gutabi.a.d.b.ab:
    com.gutabi.capsloc.world.graph.Road r -> a
    com.gutabi.capsloc.world.graph.Vertex v -> b
    int dir -> c
    com.gutabi.capsloc.math.Point p -> d
    double radius -> e
    boolean enabled -> g
    com.gutabi.capsloc.geom.Circle shape -> f
    boolean isUserDeleteable() -> c
    boolean isEnabled() -> a
    void setEnabled(boolean) -> a
    void preStart() -> d
    boolean preStep(double) -> a
    boolean postStep(double) -> c
    void computePoint() -> b
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.world.graph.Vertex -> com.gutabi.a.d.b.ac:
    double INIT_VERTEX_RADIUS -> k
    com.gutabi.capsloc.world.World world -> l
    com.gutabi.capsloc.math.Point p -> m
    java.util.List roads -> n
    com.gutabi.capsloc.world.graph.Merger m -> o
    com.gutabi.capsloc.world.graph.BypassStud s -> p
    int id -> q
    double r -> r
    java.util.List driverQueue -> s
    com.gutabi.capsloc.geom.Circle shape -> t
    int hash -> a
    boolean $assertionsDisabled -> u
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    double getRadius() -> h
    com.gutabi.capsloc.world.graph.Road bestMatchingRoad(com.gutabi.capsloc.world.graph.Road,com.gutabi.capsloc.world.graph.Road) -> a
    boolean supportsStopSigns() -> b
    java.util.List commonEdges(com.gutabi.capsloc.world.graph.Vertex,com.gutabi.capsloc.world.graph.Vertex) -> a
    void render() -> f
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintScene(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
    void paintID(com.gutabi.capsloc.ui.paint.RenderingContext) -> c
com.gutabi.capsloc.world.graph.VertexPosition -> com.gutabi.a.d.b.ad:
    com.gutabi.capsloc.world.graph.Vertex v -> a
    int hash -> c
    boolean $assertionsDisabled -> b
    int hashCode() -> hashCode
    boolean isBound() -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    com.gutabi.capsloc.world.graph.GraphPosition approachNeighbor(com.gutabi.capsloc.world.graph.GraphPosition,double) -> a
    double goalGPPPCombo(int,double,boolean,com.gutabi.capsloc.world.graph.GraphPosition,com.gutabi.capsloc.world.graph.GraphPositionPath,com.gutabi.capsloc.world.graph.GraphPositionPathPosition,double) -> a
com.gutabi.capsloc.world.physics.PhysicsBody -> com.gutabi.a.d.c.a:
    com.gutabi.capsloc.world.World world -> A
    double length -> B
    double width -> C
    double localULX -> D
    double localULY -> E
    com.gutabi.capsloc.math.Point center -> F
    double angle -> G
    com.gutabi.capsloc.geom.MutableOBB shape -> H
    double forwardSpeed -> I
    double angularVel -> J
    com.gutabi.capsloc.geom.AABB localAABB -> K
    com.gutabi.capsloc.math.Point vel -> L
    void physicsInit() -> h
    void computeDynamicPropertiesAlways() -> i
    void computeDynamicPropertiesMoving() -> j
    void setPhysicsTransform() -> k
    void setB2dCollisions(boolean) -> a
    void destroy() -> f
    void applyForwardImpulse(double,double) -> a
    void applyAngularImpulse(double,double) -> b
    void applyCancelingForwardImpulse(double) -> d
    void applyCancelingLateralImpulse(double) -> e
    void applyCancelingAngularImpulse(double) -> f
com.gutabi.capsloc.world.physics.PhysicsWorld -> com.gutabi.a.d.c.b:
    double t -> z
    boolean $assertionsDisabled -> A
    boolean step() -> l
    double getTime() -> a
    void drawPhysicsDebug(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
    boolean intersectsPhysicsBodies(com.gutabi.capsloc.geom.AABB) -> a
    boolean intersectsPhysicsBodies(com.gutabi.capsloc.geom.MutableAABB) -> a
com.gutabi.capsloc.world.sprites.AnimatedGrass -> com.gutabi.a.d.d.a:
    double GRASS_SIZE -> a
    com.gutabi.capsloc.math.Point p -> b
    int lastFrame -> c
    double lastTime -> d
    double phase -> e
    int startFrame -> f
    com.gutabi.capsloc.geom.AABB aabb -> g
    void preStart() -> a
    boolean step(double) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.world.sprites.CarSheet -> com.gutabi.a.d.d.b:
    boolean $assertionsDisabled -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$sprites$CarSheet$CarType -> d
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite sprite(int) -> a
    int sheetIndex(com.gutabi.capsloc.world.sprites.CarSheet$CarType,int) -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$sprites$CarSheet$CarType() -> a
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite -> com.gutabi.a.d.d.c:
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite RED -> a
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite CAR0 -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite CAR1 -> c
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite CAR2 -> d
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite CAR3 -> e
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite CAR4 -> f
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite CAR5 -> g
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite CAR6 -> h
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite TRUCK0 -> i
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite TRUCK1 -> j
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite TRUCK2 -> k
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite TRUCK3 -> l
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite TRUCK4 -> m
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite TRUCK5 -> n
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite TRUCK6 -> o
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite[] ENUM$VALUES -> p
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite[] values() -> values
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$1 -> com.gutabi.a.d.d.d:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$10 -> com.gutabi.a.d.d.e:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$11 -> com.gutabi.a.d.d.f:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$12 -> com.gutabi.a.d.d.g:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$13 -> com.gutabi.a.d.d.h:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$14 -> com.gutabi.a.d.d.i:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$15 -> com.gutabi.a.d.d.j:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$2 -> com.gutabi.a.d.d.k:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$3 -> com.gutabi.a.d.d.l:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$4 -> com.gutabi.a.d.d.m:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$5 -> com.gutabi.a.d.d.n:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$6 -> com.gutabi.a.d.d.o:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$7 -> com.gutabi.a.d.d.p:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$8 -> com.gutabi.a.d.d.q:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$9 -> com.gutabi.a.d.d.r:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarType -> com.gutabi.a.d.d.s:
    com.gutabi.capsloc.world.sprites.CarSheet$CarType TWO -> a
    com.gutabi.capsloc.world.sprites.CarSheet$CarType THREE -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType RED -> c
    com.gutabi.capsloc.world.sprites.CarSheet$CarType[] ENUM$VALUES -> d
    com.gutabi.capsloc.world.sprites.CarSheet$CarType[] values() -> values
    com.gutabi.capsloc.world.sprites.CarSheet$CarType valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.sprites.Sheet -> com.gutabi.a.d.d.t:
    com.gutabi.capsloc.Resource res -> b
    com.gutabi.capsloc.ui.Image img -> c
    void load() -> b
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext,com.gutabi.capsloc.world.sprites.Sprite,int,int,int,int) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext,com.gutabi.capsloc.world.sprites.Sprite,double,double,double,double,double) -> a
com.gutabi.capsloc.world.sprites.Sprite -> com.gutabi.a.d.d.u:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet -> com.gutabi.a.d.d.v:
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite -> com.gutabi.a.d.d.w:
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite INNERSTUD -> a
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite TOPSTUD -> b
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite RIGHTSTUD -> c
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite BOTTOMSTUD -> d
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite LEFTSTUD -> e
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite GRASSTILE -> f
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite GRASS0 -> g
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite GRASS1 -> h
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite GRASS2 -> i
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite BLUEARROW -> j
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite BRAKE -> k
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite FIXTUREARROW -> l
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite STOPSIGN -> m
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite[] ENUM$VALUES -> n
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite[] values() -> values
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$1 -> com.gutabi.a.d.d.x:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$10 -> com.gutabi.a.d.d.y:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$11 -> com.gutabi.a.d.d.z:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$12 -> com.gutabi.a.d.d.aa:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$13 -> com.gutabi.a.d.d.ab:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$2 -> com.gutabi.a.d.d.ac:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$3 -> com.gutabi.a.d.d.ad:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$4 -> com.gutabi.a.d.d.ae:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$5 -> com.gutabi.a.d.d.af:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$6 -> com.gutabi.a.d.d.ag:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$7 -> com.gutabi.a.d.d.ah:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$8 -> com.gutabi.a.d.d.ai:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$9 -> com.gutabi.a.d.d.aj:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.tools.Motion -> com.gutabi.a.d.e.a:
    com.gutabi.capsloc.world.tools.Motion PRESSED -> a
    com.gutabi.capsloc.world.tools.Motion DRAGGED -> b
    com.gutabi.capsloc.world.tools.Motion RELEASED -> c
    com.gutabi.capsloc.world.tools.Motion CANCELED -> d
    com.gutabi.capsloc.world.tools.Motion[] ENUM$VALUES -> e
    com.gutabi.capsloc.world.tools.Motion[] values() -> values
    com.gutabi.capsloc.world.tools.Motion valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.tools.WorldToolBase -> com.gutabi.a.d.e.b:
    com.gutabi.capsloc.world.tools.Motion lastMotion -> m
    void pressed(com.gutabi.capsloc.ui.InputEvent) -> a
    void dragged(com.gutabi.capsloc.ui.InputEvent) -> d
    void released(com.gutabi.capsloc.ui.InputEvent) -> b
    void canceled(com.gutabi.capsloc.ui.InputEvent) -> c
