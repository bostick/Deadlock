android.support.v4.app.ActivityCompatHoneycomb -> android.support.v4.app.a:
    void invalidateOptionsMenu(android.app.Activity) -> a
android.support.v4.app.BackStackRecord -> android.support.v4.app.b:
    android.support.v4.app.FragmentManagerImpl mManager -> a
    android.support.v4.app.BackStackRecord$Op mHead -> b
    android.support.v4.app.BackStackRecord$Op mTail -> c
    int mNumOp -> d
    int mEnterAnim -> e
    int mExitAnim -> f
    int mPopEnterAnim -> g
    int mPopExitAnim -> h
    int mTransition -> i
    int mTransitionStyle -> j
    boolean mAddToBackStack -> k
    boolean mAllowAddToBackStack -> l
    java.lang.String mName -> m
    boolean mCommitted -> n
    int mIndex -> o
    int mBreadCrumbTitleRes -> p
    java.lang.CharSequence mBreadCrumbTitleText -> q
    int mBreadCrumbShortTitleRes -> r
    java.lang.CharSequence mBreadCrumbShortTitleText -> s
    java.lang.String toString() -> toString
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    void dump(java.lang.String,java.io.PrintWriter,boolean) -> a
    void addOp(android.support.v4.app.BackStackRecord$Op) -> a
    android.support.v4.app.FragmentTransaction add(int,android.support.v4.app.Fragment,java.lang.String) -> a
    void doAddOp(int,android.support.v4.app.Fragment,java.lang.String,int) -> a
    android.support.v4.app.FragmentTransaction detach(android.support.v4.app.Fragment) -> a
    android.support.v4.app.FragmentTransaction attach(android.support.v4.app.Fragment) -> b
    void bumpBackStackNesting(int) -> a
    int commit() -> a
    int commitInternal(boolean) -> a
    void run() -> run
    void popFromBackStack(boolean) -> b
    java.lang.String getName() -> b
android.support.v4.app.BackStackRecord$Op -> android.support.v4.app.c:
    android.support.v4.app.BackStackRecord$Op next -> a
    android.support.v4.app.BackStackRecord$Op prev -> b
    int cmd -> c
    android.support.v4.app.Fragment fragment -> d
    int enterAnim -> e
    int exitAnim -> f
    int popEnterAnim -> g
    int popExitAnim -> h
    java.util.ArrayList removed -> i
android.support.v4.app.BackStackState -> android.support.v4.app.BackStackState:
    int[] mOps -> a
    int mTransition -> b
    int mTransitionStyle -> c
    java.lang.String mName -> d
    int mIndex -> e
    int mBreadCrumbTitleRes -> f
    java.lang.CharSequence mBreadCrumbTitleText -> g
    int mBreadCrumbShortTitleRes -> h
    java.lang.CharSequence mBreadCrumbShortTitleText -> i
    android.os.Parcelable$Creator CREATOR -> CREATOR
    android.support.v4.app.BackStackRecord instantiate(android.support.v4.app.FragmentManagerImpl) -> a
    int describeContents() -> describeContents
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
android.support.v4.app.BackStackState$1 -> android.support.v4.app.d:
    android.support.v4.app.BackStackState createFromParcel(android.os.Parcel) -> a
    android.support.v4.app.BackStackState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.app.Fragment -> android.support.v4.app.Fragment:
    java.util.HashMap sClassMap -> P
    int mState -> a
    android.view.View mAnimatingAway -> b
    int mStateAfterAnimating -> c
    android.os.Bundle mSavedFragmentState -> d
    android.util.SparseArray mSavedViewState -> e
    int mIndex -> f
    java.lang.String mWho -> g
    android.os.Bundle mArguments -> h
    android.support.v4.app.Fragment mTarget -> i
    int mTargetIndex -> j
    int mTargetRequestCode -> k
    boolean mAdded -> l
    boolean mRemoving -> m
    boolean mResumed -> n
    boolean mFromLayout -> o
    boolean mInLayout -> p
    boolean mRestored -> q
    int mBackStackNesting -> r
    android.support.v4.app.FragmentManagerImpl mFragmentManager -> s
    android.support.v4.app.FragmentActivity mActivity -> t
    android.support.v4.app.FragmentManagerImpl mChildFragmentManager -> u
    android.support.v4.app.Fragment mParentFragment -> v
    int mFragmentId -> w
    int mContainerId -> x
    java.lang.String mTag -> y
    boolean mHidden -> z
    boolean mDetached -> A
    boolean mRetainInstance -> B
    boolean mRetaining -> C
    boolean mHasMenu -> D
    boolean mMenuVisible -> E
    boolean mCalled -> F
    int mNextAnim -> G
    android.view.ViewGroup mContainer -> H
    android.view.View mView -> I
    android.view.View mInnerView -> J
    boolean mDeferStart -> K
    boolean mUserVisibleHint -> L
    android.support.v4.app.LoaderManagerImpl mLoaderManager -> M
    boolean mLoadersStarted -> N
    boolean mCheckedForLoaderManager -> O
    android.support.v4.app.Fragment instantiate(android.content.Context,java.lang.String) -> a
    android.support.v4.app.Fragment instantiate(android.content.Context,java.lang.String,android.os.Bundle) -> a
    void restoreViewState(android.os.Bundle) -> a
    void setIndex(int,android.support.v4.app.Fragment) -> a
    boolean isInBackStack() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    android.support.v4.app.FragmentActivity getActivity() -> b
    android.content.res.Resources getResources() -> c
    boolean isDetached() -> d
    void onHiddenChanged(boolean) -> a
    void onActivityResult(int,int,android.content.Intent) -> a
    android.view.LayoutInflater getLayoutInflater(android.os.Bundle) -> b
    void onInflate(android.app.Activity,android.util.AttributeSet,android.os.Bundle) -> a
    void onAttach(android.app.Activity) -> a
    android.view.animation.Animation onCreateAnimation(int,boolean,int) -> a
    void onCreate(android.os.Bundle) -> c
    android.view.View onCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle) -> a
    void onViewCreated(android.view.View,android.os.Bundle) -> a
    void onActivityCreated(android.os.Bundle) -> d
    void onViewStateRestored(android.os.Bundle) -> e
    void onStart() -> e
    void onResume() -> f
    void onSaveInstanceState(android.os.Bundle) -> f
    void onConfigurationChanged(android.content.res.Configuration) -> onConfigurationChanged
    void onPause() -> g
    void onStop() -> h
    void onLowMemory() -> onLowMemory
    void onDestroyView() -> i
    void onDestroy() -> j
    void initState() -> k
    void onDetach() -> l
    void onCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> a
    void onPrepareOptionsMenu(android.view.Menu) -> a
    void onDestroyOptionsMenu() -> m
    boolean onOptionsItemSelected(android.view.MenuItem) -> a
    void onOptionsMenuClosed(android.view.Menu) -> b
    void onCreateContextMenu(android.view.ContextMenu,android.view.View,android.view.ContextMenu$ContextMenuInfo) -> onCreateContextMenu
    boolean onContextItemSelected(android.view.MenuItem) -> b
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    void instantiateChildFragmentManager() -> n
    void performCreate(android.os.Bundle) -> g
    android.view.View performCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle) -> b
    void performActivityCreated(android.os.Bundle) -> h
    void performStart() -> o
    void performResume() -> p
    void performConfigurationChanged(android.content.res.Configuration) -> a
    void performLowMemory() -> q
    boolean performCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> b
    boolean performPrepareOptionsMenu(android.view.Menu) -> c
    boolean performOptionsItemSelected(android.view.MenuItem) -> c
    boolean performContextItemSelected(android.view.MenuItem) -> d
    void performOptionsMenuClosed(android.view.Menu) -> d
    void performSaveInstanceState(android.os.Bundle) -> i
    void performPause() -> r
    void performStop() -> s
    void performReallyStop() -> t
    void performDestroyView() -> u
    void performDestroy() -> v
android.support.v4.app.Fragment$1 -> android.support.v4.app.e:
    android.support.v4.app.Fragment this$0 -> a
    android.view.View findViewById(int) -> a
android.support.v4.app.Fragment$InstantiationException -> android.support.v4.app.f:
android.support.v4.app.Fragment$SavedState -> android.support.v4.app.Fragment$SavedState:
    android.os.Bundle mState -> a
    android.os.Parcelable$Creator CREATOR -> CREATOR
    int describeContents() -> describeContents
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
android.support.v4.app.Fragment$SavedState$1 -> android.support.v4.app.g:
    android.support.v4.app.Fragment$SavedState createFromParcel(android.os.Parcel) -> a
    android.support.v4.app.Fragment$SavedState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.app.FragmentActivity -> android.support.v4.app.h:
    android.os.Handler mHandler -> a
    android.support.v4.app.FragmentManagerImpl mFragments -> b
    android.support.v4.app.FragmentContainer mContainer -> c
    boolean mCreated -> d
    boolean mResumed -> e
    boolean mStopped -> f
    boolean mReallyStopped -> g
    boolean mRetaining -> h
    boolean mOptionsMenuInvalidated -> i
    boolean mCheckedForLoaderManager -> j
    boolean mLoadersStarted -> k
    java.util.HashMap mAllLoaderManagers -> l
    android.support.v4.app.LoaderManagerImpl mLoaderManager -> m
    void onActivityResult(int,int,android.content.Intent) -> onActivityResult
    void onBackPressed() -> onBackPressed
    void onConfigurationChanged(android.content.res.Configuration) -> onConfigurationChanged
    void onCreate(android.os.Bundle) -> onCreate
    boolean onCreatePanelMenu(int,android.view.Menu) -> onCreatePanelMenu
    android.view.View onCreateView(java.lang.String,android.content.Context,android.util.AttributeSet) -> onCreateView
    void onDestroy() -> onDestroy
    boolean onKeyDown(int,android.view.KeyEvent) -> onKeyDown
    void onLowMemory() -> onLowMemory
    boolean onMenuItemSelected(int,android.view.MenuItem) -> onMenuItemSelected
    void onPanelClosed(int,android.view.Menu) -> onPanelClosed
    void onPause() -> onPause
    void onNewIntent(android.content.Intent) -> onNewIntent
    void onResume() -> onResume
    void onPostResume() -> onPostResume
    void onResumeFragments() -> a
    boolean onPreparePanel(int,android.view.View,android.view.Menu) -> onPreparePanel
    java.lang.Object onRetainNonConfigurationInstance() -> onRetainNonConfigurationInstance
    void onSaveInstanceState(android.os.Bundle) -> onSaveInstanceState
    void onStart() -> onStart
    void onStop() -> onStop
    java.lang.Object onRetainCustomNonConfigurationInstance() -> b
    void supportInvalidateOptionsMenu() -> c
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> dump
    java.lang.String viewToString(android.view.View) -> a
    void dumpViewHierarchy(java.lang.String,java.io.PrintWriter,android.view.View) -> a
    void doReallyStop(boolean) -> a
    void onReallyStop() -> d
    void onAttachFragment(android.support.v4.app.Fragment) -> a
    void startActivityForResult(android.content.Intent,int) -> startActivityForResult
    void invalidateSupportFragment(java.lang.String) -> a
    android.support.v4.app.LoaderManagerImpl getLoaderManager(java.lang.String,boolean,boolean) -> a
android.support.v4.app.FragmentActivity$FragmentTag -> android.support.v4.app.i:
    int[] Fragment -> a
android.support.v4.app.FragmentActivity$NonConfigurationInstances -> android.support.v4.app.j:
    java.lang.Object activity -> a
    java.lang.Object custom -> b
    java.util.HashMap children -> c
    java.util.ArrayList fragments -> d
    java.util.HashMap loaders -> e
android.support.v4.app.FragmentContainer -> android.support.v4.app.k:
    android.view.View findViewById(int) -> a
android.support.v4.app.FragmentManager -> android.support.v4.app.l:
    android.support.v4.app.FragmentTransaction beginTransaction() -> a
    boolean executePendingTransactions() -> b
    android.support.v4.app.Fragment findFragmentByTag(java.lang.String) -> a
android.support.v4.app.FragmentManager$OnBackStackChangedListener -> android.support.v4.app.m:
    void onBackStackChanged() -> a
android.support.v4.app.FragmentManagerImpl -> android.support.v4.app.n:
    boolean DEBUG -> a
    boolean HONEYCOMB -> b
    java.util.ArrayList mPendingActions -> c
    java.lang.Runnable[] mTmpActions -> d
    boolean mExecutingActions -> e
    java.util.ArrayList mActive -> f
    java.util.ArrayList mAdded -> g
    java.util.ArrayList mAvailIndices -> h
    java.util.ArrayList mBackStack -> i
    java.util.ArrayList mCreatedMenus -> j
    java.util.ArrayList mBackStackIndices -> k
    java.util.ArrayList mAvailBackStackIndices -> l
    java.util.ArrayList mBackStackChangeListeners -> m
    int mCurState -> n
    android.support.v4.app.FragmentActivity mActivity -> o
    android.support.v4.app.FragmentContainer mContainer -> p
    android.support.v4.app.Fragment mParent -> q
    boolean mNeedMenuInvalidate -> r
    boolean mStateSaved -> s
    boolean mDestroyed -> t
    java.lang.String mNoTransactionsBecause -> u
    boolean mHavePendingDeferredStart -> v
    android.os.Bundle mStateBundle -> w
    android.util.SparseArray mStateArray -> x
    java.lang.Runnable mExecCommit -> y
    android.view.animation.Interpolator DECELERATE_QUINT -> z
    android.view.animation.Interpolator DECELERATE_CUBIC -> A
    android.view.animation.Interpolator ACCELERATE_QUINT -> B
    android.view.animation.Interpolator ACCELERATE_CUBIC -> C
    void throwException(java.lang.RuntimeException) -> a
    android.support.v4.app.FragmentTransaction beginTransaction() -> a
    boolean executePendingTransactions() -> b
    boolean popBackStackImmediate() -> c
    void putFragment(android.os.Bundle,java.lang.String,android.support.v4.app.Fragment) -> a
    android.support.v4.app.Fragment getFragment(android.os.Bundle,java.lang.String) -> a
    java.lang.String toString() -> toString
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    android.view.animation.Animation makeOpenCloseAnimation(android.content.Context,float,float,float,float) -> a
    android.view.animation.Animation makeFadeAnimation(android.content.Context,float,float) -> a
    android.view.animation.Animation loadAnimation(android.support.v4.app.Fragment,int,boolean,int) -> a
    void performPendingDeferredStart(android.support.v4.app.Fragment) -> a
    void moveToState(android.support.v4.app.Fragment,int,int,int,boolean) -> a
    void moveToState(android.support.v4.app.Fragment) -> b
    void moveToState(int,boolean) -> a
    void moveToState(int,int,int,boolean) -> a
    void startPendingDeferredFragments() -> d
    void makeActive(android.support.v4.app.Fragment) -> c
    void makeInactive(android.support.v4.app.Fragment) -> d
    void addFragment(android.support.v4.app.Fragment,boolean) -> a
    void removeFragment(android.support.v4.app.Fragment,int,int) -> a
    void hideFragment(android.support.v4.app.Fragment,int,int) -> b
    void showFragment(android.support.v4.app.Fragment,int,int) -> c
    void detachFragment(android.support.v4.app.Fragment,int,int) -> d
    void attachFragment(android.support.v4.app.Fragment,int,int) -> e
    android.support.v4.app.Fragment findFragmentById(int) -> a
    android.support.v4.app.Fragment findFragmentByTag(java.lang.String) -> a
    void checkStateLoss() -> t
    void enqueueAction(java.lang.Runnable,boolean) -> a
    int allocBackStackIndex(android.support.v4.app.BackStackRecord) -> a
    void setBackStackIndex(int,android.support.v4.app.BackStackRecord) -> a
    void freeBackStackIndex(int) -> b
    boolean execPendingActions() -> e
    void reportBackStackChanged() -> f
    void addBackStackState(android.support.v4.app.BackStackRecord) -> b
    boolean popBackStackState(android.os.Handler,java.lang.String,int,int) -> a
    java.util.ArrayList retainNonConfig() -> g
    void saveFragmentViewState(android.support.v4.app.Fragment) -> e
    android.os.Bundle saveFragmentBasicState(android.support.v4.app.Fragment) -> f
    android.os.Parcelable saveAllState() -> h
    void restoreAllState(android.os.Parcelable,java.util.ArrayList) -> a
    void attachActivity(android.support.v4.app.FragmentActivity,android.support.v4.app.FragmentContainer,android.support.v4.app.Fragment) -> a
    void noteStateNotSaved() -> i
    void dispatchCreate() -> j
    void dispatchActivityCreated() -> k
    void dispatchStart() -> l
    void dispatchResume() -> m
    void dispatchPause() -> n
    void dispatchStop() -> o
    void dispatchReallyStop() -> p
    void dispatchDestroyView() -> q
    void dispatchDestroy() -> r
    void dispatchConfigurationChanged(android.content.res.Configuration) -> a
    void dispatchLowMemory() -> s
    boolean dispatchCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> a
    boolean dispatchPrepareOptionsMenu(android.view.Menu) -> a
    boolean dispatchOptionsItemSelected(android.view.MenuItem) -> a
    boolean dispatchContextItemSelected(android.view.MenuItem) -> b
    void dispatchOptionsMenuClosed(android.view.Menu) -> b
    int reverseTransit(int) -> c
    int transitToStyleIndex(int,boolean) -> b
android.support.v4.app.FragmentManagerImpl$1 -> android.support.v4.app.o:
    android.support.v4.app.FragmentManagerImpl this$0 -> a
    void run() -> run
android.support.v4.app.FragmentManagerImpl$5 -> android.support.v4.app.p:
    android.support.v4.app.Fragment val$fragment -> a
    android.support.v4.app.FragmentManagerImpl this$0 -> b
    void onAnimationEnd(android.view.animation.Animation) -> onAnimationEnd
    void onAnimationRepeat(android.view.animation.Animation) -> onAnimationRepeat
    void onAnimationStart(android.view.animation.Animation) -> onAnimationStart
android.support.v4.app.FragmentManagerState -> android.support.v4.app.FragmentManagerState:
    android.support.v4.app.FragmentState[] mActive -> a
    int[] mAdded -> b
    android.support.v4.app.BackStackState[] mBackStack -> c
    android.os.Parcelable$Creator CREATOR -> CREATOR
    int describeContents() -> describeContents
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
android.support.v4.app.FragmentManagerState$1 -> android.support.v4.app.q:
    android.support.v4.app.FragmentManagerState createFromParcel(android.os.Parcel) -> a
    android.support.v4.app.FragmentManagerState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.app.FragmentState -> android.support.v4.app.FragmentState:
    java.lang.String mClassName -> a
    int mIndex -> b
    boolean mFromLayout -> c
    int mFragmentId -> d
    int mContainerId -> e
    java.lang.String mTag -> f
    boolean mRetainInstance -> g
    boolean mDetached -> h
    android.os.Bundle mArguments -> i
    android.os.Bundle mSavedFragmentState -> j
    android.support.v4.app.Fragment mInstance -> k
    android.os.Parcelable$Creator CREATOR -> CREATOR
    android.support.v4.app.Fragment instantiate(android.support.v4.app.FragmentActivity,android.support.v4.app.Fragment) -> a
    int describeContents() -> describeContents
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
android.support.v4.app.FragmentState$1 -> android.support.v4.app.r:
    android.support.v4.app.FragmentState createFromParcel(android.os.Parcel) -> a
    android.support.v4.app.FragmentState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.app.FragmentTabHost -> android.support.v4.app.FragmentTabHost:
    java.util.ArrayList mTabs -> a
    android.content.Context mContext -> b
    android.support.v4.app.FragmentManager mFragmentManager -> c
    int mContainerId -> d
    android.widget.TabHost$OnTabChangeListener mOnTabChangeListener -> e
    android.support.v4.app.FragmentTabHost$TabInfo mLastTab -> f
    boolean mAttached -> g
    void setup() -> setup
    void setOnTabChangedListener(android.widget.TabHost$OnTabChangeListener) -> setOnTabChangedListener
    void onAttachedToWindow() -> onAttachedToWindow
    void onDetachedFromWindow() -> onDetachedFromWindow
    android.os.Parcelable onSaveInstanceState() -> onSaveInstanceState
    void onRestoreInstanceState(android.os.Parcelable) -> onRestoreInstanceState
    void onTabChanged(java.lang.String) -> onTabChanged
    android.support.v4.app.FragmentTransaction doTabChanged(java.lang.String,android.support.v4.app.FragmentTransaction) -> a
android.support.v4.app.FragmentTabHost$1 -> android.support.v4.app.s:
android.support.v4.app.FragmentTabHost$SavedState -> android.support.v4.app.FragmentTabHost$SavedState:
    java.lang.String curTab -> a
    android.os.Parcelable$Creator CREATOR -> CREATOR
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
    java.lang.String toString() -> toString
android.support.v4.app.FragmentTabHost$SavedState$1 -> android.support.v4.app.t:
    android.support.v4.app.FragmentTabHost$SavedState createFromParcel(android.os.Parcel) -> a
    android.support.v4.app.FragmentTabHost$SavedState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.app.FragmentTabHost$TabInfo -> android.support.v4.app.u:
    java.lang.String tag -> a
    java.lang.Class clss -> b
    android.os.Bundle args -> c
    android.support.v4.app.Fragment fragment -> d
    android.support.v4.app.Fragment access$102(android.support.v4.app.FragmentTabHost$TabInfo,android.support.v4.app.Fragment) -> a
    android.support.v4.app.Fragment access$100(android.support.v4.app.FragmentTabHost$TabInfo) -> a
    java.lang.String access$200(android.support.v4.app.FragmentTabHost$TabInfo) -> b
    java.lang.Class access$300(android.support.v4.app.FragmentTabHost$TabInfo) -> c
    android.os.Bundle access$400(android.support.v4.app.FragmentTabHost$TabInfo) -> d
android.support.v4.app.FragmentTransaction -> android.support.v4.app.v:
    android.support.v4.app.FragmentTransaction add(int,android.support.v4.app.Fragment,java.lang.String) -> a
    android.support.v4.app.FragmentTransaction detach(android.support.v4.app.Fragment) -> a
    android.support.v4.app.FragmentTransaction attach(android.support.v4.app.Fragment) -> b
    int commit() -> a
android.support.v4.app.LoaderManager -> android.support.v4.app.w:
    boolean hasRunningLoaders() -> a
android.support.v4.app.LoaderManager$LoaderCallbacks -> android.support.v4.app.x:
    android.support.v4.content.Loader onCreateLoader(int,android.os.Bundle) -> a
    void onLoadFinished(android.support.v4.content.Loader,java.lang.Object) -> a
    void onLoaderReset(android.support.v4.content.Loader) -> a
android.support.v4.app.LoaderManagerImpl -> android.support.v4.app.y:
    boolean DEBUG -> a
    android.support.v4.util.SparseArrayCompat mLoaders -> b
    android.support.v4.util.SparseArrayCompat mInactiveLoaders -> c
    java.lang.String mWho -> d
    android.support.v4.app.FragmentActivity mActivity -> e
    boolean mStarted -> f
    boolean mRetaining -> g
    void updateActivity(android.support.v4.app.FragmentActivity) -> a
    void doStart() -> b
    void doStop() -> c
    void doRetain() -> d
    void finishRetain() -> e
    void doReportNextStart() -> f
    void doReportStart() -> g
    void doDestroy() -> h
    java.lang.String toString() -> toString
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    boolean hasRunningLoaders() -> a
android.support.v4.app.LoaderManagerImpl$LoaderInfo -> android.support.v4.app.z:
    int mId -> a
    android.os.Bundle mArgs -> b
    android.support.v4.app.LoaderManager$LoaderCallbacks mCallbacks -> c
    android.support.v4.content.Loader mLoader -> d
    boolean mHaveData -> e
    boolean mDeliveredData -> f
    java.lang.Object mData -> g
    boolean mStarted -> h
    boolean mRetaining -> i
    boolean mRetainingStarted -> j
    boolean mReportNextStart -> k
    boolean mDestroyed -> l
    boolean mListenerRegistered -> m
    android.support.v4.app.LoaderManagerImpl$LoaderInfo mPendingLoader -> n
    android.support.v4.app.LoaderManagerImpl this$0 -> o
    void start() -> a
    void retain() -> b
    void finishRetain() -> c
    void reportStart() -> d
    void stop() -> e
    void destroy() -> f
    void callOnLoadFinished(android.support.v4.content.Loader,java.lang.Object) -> a
    java.lang.String toString() -> toString
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
android.support.v4.app.NoSaveStateFrameLayout -> android.support.v4.app.aa:
    android.view.ViewGroup wrap(android.view.View) -> a
    void dispatchSaveInstanceState(android.util.SparseArray) -> dispatchSaveInstanceState
    void dispatchRestoreInstanceState(android.util.SparseArray) -> dispatchRestoreInstanceState
android.support.v4.app.SuperNotCalledException -> android.support.v4.app.ab:
android.support.v4.content.Loader -> android.support.v4.a.a:
    int mId -> a
    android.support.v4.content.Loader$OnLoadCompleteListener mListener -> b
    boolean mStarted -> c
    boolean mAbandoned -> d
    boolean mReset -> e
    boolean mContentChanged -> f
    void registerListener(int,android.support.v4.content.Loader$OnLoadCompleteListener) -> a
    void unregisterListener(android.support.v4.content.Loader$OnLoadCompleteListener) -> a
    void startLoading() -> a
    void onStartLoading() -> b
    void stopLoading() -> c
    void onStopLoading() -> d
    void reset() -> e
    void onReset() -> f
    java.lang.String dataToString(java.lang.Object) -> a
    java.lang.String toString() -> toString
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
android.support.v4.content.Loader$OnLoadCompleteListener -> android.support.v4.a.b:
android.support.v4.os.ParcelableCompat -> android.support.v4.b.a:
    android.os.Parcelable$Creator newCreator(android.support.v4.os.ParcelableCompatCreatorCallbacks) -> a
android.support.v4.os.ParcelableCompat$CompatCreator -> android.support.v4.b.b:
    android.support.v4.os.ParcelableCompatCreatorCallbacks mCallbacks -> a
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
    java.lang.Object[] newArray(int) -> newArray
android.support.v4.os.ParcelableCompatCreatorCallbacks -> android.support.v4.b.c:
    java.lang.Object createFromParcel(android.os.Parcel,java.lang.ClassLoader) -> a
    java.lang.Object[] newArray(int) -> a
android.support.v4.os.ParcelableCompatCreatorHoneycombMR2 -> android.support.v4.b.d:
    android.support.v4.os.ParcelableCompatCreatorCallbacks mCallbacks -> a
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
    java.lang.Object createFromParcel(android.os.Parcel,java.lang.ClassLoader) -> createFromParcel
    java.lang.Object[] newArray(int) -> newArray
android.support.v4.os.ParcelableCompatCreatorHoneycombMR2Stub -> android.support.v4.b.e:
    android.os.Parcelable$Creator instantiate(android.support.v4.os.ParcelableCompatCreatorCallbacks) -> a
android.support.v4.util.DebugUtils -> android.support.v4.c.a:
    void buildShortClassTag(java.lang.Object,java.lang.StringBuilder) -> a
android.support.v4.util.LogWriter -> android.support.v4.c.b:
    java.lang.String mTag -> a
    java.lang.StringBuilder mBuilder -> b
    void close() -> close
    void flush() -> flush
    void write(char[],int,int) -> write
    void flushBuilder() -> a
android.support.v4.util.SparseArrayCompat -> android.support.v4.c.c:
    java.lang.Object DELETED -> a
    boolean mGarbage -> b
    int[] mKeys -> c
    java.lang.Object[] mValues -> d
    int mSize -> e
    void gc() -> c
    int size() -> a
    int keyAt(int) -> a
    java.lang.Object valueAt(int) -> b
    void clear() -> b
    int idealByteArraySize(int) -> c
    int idealIntArraySize(int) -> d
android.support.v4.view.KeyEventCompat -> android.support.v4.view.a:
    android.support.v4.view.KeyEventCompat$KeyEventVersionImpl IMPL -> a
    boolean hasModifiers(android.view.KeyEvent,int) -> a
    boolean hasNoModifiers(android.view.KeyEvent) -> a
android.support.v4.view.KeyEventCompat$BaseKeyEventVersionImpl -> android.support.v4.view.b:
    int metaStateFilterDirectionalModifiers(int,int,int,int,int) -> a
    int normalizeMetaState(int) -> a
    boolean metaStateHasModifiers(int,int) -> a
    boolean metaStateHasNoModifiers(int) -> b
android.support.v4.view.KeyEventCompat$HoneycombKeyEventVersionImpl -> android.support.v4.view.c:
    boolean metaStateHasModifiers(int,int) -> a
    boolean metaStateHasNoModifiers(int) -> b
android.support.v4.view.KeyEventCompat$KeyEventVersionImpl -> android.support.v4.view.d:
    boolean metaStateHasModifiers(int,int) -> a
    boolean metaStateHasNoModifiers(int) -> b
android.support.v4.view.KeyEventCompatHoneycomb -> android.support.v4.view.e:
    boolean metaStateHasModifiers(int,int) -> a
    boolean metaStateHasNoModifiers(int) -> a
android.support.v4.view.MotionEventCompat -> android.support.v4.view.f:
    android.support.v4.view.MotionEventCompat$MotionEventVersionImpl IMPL -> a
    int getActionIndex(android.view.MotionEvent) -> a
    int findPointerIndex(android.view.MotionEvent,int) -> a
    int getPointerId(android.view.MotionEvent,int) -> b
    float getX(android.view.MotionEvent,int) -> c
    float getY(android.view.MotionEvent,int) -> d
android.support.v4.view.MotionEventCompat$BaseMotionEventVersionImpl -> android.support.v4.view.g:
    int findPointerIndex(android.view.MotionEvent,int) -> a
    int getPointerId(android.view.MotionEvent,int) -> b
    float getX(android.view.MotionEvent,int) -> c
    float getY(android.view.MotionEvent,int) -> d
android.support.v4.view.MotionEventCompat$EclairMotionEventVersionImpl -> android.support.v4.view.h:
    int findPointerIndex(android.view.MotionEvent,int) -> a
    int getPointerId(android.view.MotionEvent,int) -> b
    float getX(android.view.MotionEvent,int) -> c
    float getY(android.view.MotionEvent,int) -> d
android.support.v4.view.MotionEventCompat$MotionEventVersionImpl -> android.support.v4.view.i:
    int findPointerIndex(android.view.MotionEvent,int) -> a
    int getPointerId(android.view.MotionEvent,int) -> b
    float getX(android.view.MotionEvent,int) -> c
    float getY(android.view.MotionEvent,int) -> d
android.support.v4.view.MotionEventCompatEclair -> android.support.v4.view.j:
    int findPointerIndex(android.view.MotionEvent,int) -> a
    int getPointerId(android.view.MotionEvent,int) -> b
    float getX(android.view.MotionEvent,int) -> c
    float getY(android.view.MotionEvent,int) -> d
android.support.v4.view.PagerAdapter -> android.support.v4.view.k:
    android.database.DataSetObservable mObservable -> a
    int getCount() -> a
    void startUpdate(android.view.ViewGroup) -> a
    java.lang.Object instantiateItem(android.view.ViewGroup,int) -> a
    void destroyItem(android.view.ViewGroup,int,java.lang.Object) -> a
    void setPrimaryItem(android.view.ViewGroup,int,java.lang.Object) -> b
    void finishUpdate(android.view.ViewGroup) -> b
    void startUpdate(android.view.View) -> a
    java.lang.Object instantiateItem(android.view.View,int) -> a
    void destroyItem(android.view.View,int,java.lang.Object) -> a
    void setPrimaryItem(android.view.View,int,java.lang.Object) -> b
    void finishUpdate(android.view.View) -> b
    boolean isViewFromObject(android.view.View,java.lang.Object) -> a
    android.os.Parcelable saveState() -> b
    void restoreState(android.os.Parcelable,java.lang.ClassLoader) -> a
    int getItemPosition(java.lang.Object) -> a
    void registerDataSetObserver(android.database.DataSetObserver) -> a
    void unregisterDataSetObserver(android.database.DataSetObserver) -> b
    float getPageWidth(int) -> a
android.support.v4.view.VelocityTrackerCompat -> android.support.v4.view.l:
    android.support.v4.view.VelocityTrackerCompat$VelocityTrackerVersionImpl IMPL -> a
    float getXVelocity(android.view.VelocityTracker,int) -> a
android.support.v4.view.VelocityTrackerCompat$BaseVelocityTrackerVersionImpl -> android.support.v4.view.m:
    float getXVelocity(android.view.VelocityTracker,int) -> a
android.support.v4.view.VelocityTrackerCompat$HoneycombVelocityTrackerVersionImpl -> android.support.v4.view.n:
    float getXVelocity(android.view.VelocityTracker,int) -> a
android.support.v4.view.VelocityTrackerCompat$VelocityTrackerVersionImpl -> android.support.v4.view.o:
    float getXVelocity(android.view.VelocityTracker,int) -> a
android.support.v4.view.VelocityTrackerCompatHoneycomb -> android.support.v4.view.p:
    float getXVelocity(android.view.VelocityTracker,int) -> a
android.support.v4.view.ViewCompat -> android.support.v4.view.q:
    android.support.v4.view.ViewCompat$ViewCompatImpl IMPL -> a
    boolean canScrollHorizontally(android.view.View,int) -> a
    int getOverScrollMode(android.view.View) -> a
    void postInvalidateOnAnimation(android.view.View) -> b
    void postOnAnimation(android.view.View,java.lang.Runnable) -> a
    void setLayerType(android.view.View,int,android.graphics.Paint) -> a
android.support.v4.view.ViewCompat$BaseViewCompatImpl -> android.support.v4.view.r:
    boolean canScrollHorizontally(android.view.View,int) -> a
    int getOverScrollMode(android.view.View) -> a
    void postInvalidateOnAnimation(android.view.View) -> b
    void postOnAnimation(android.view.View,java.lang.Runnable) -> a
    long getFrameTime() -> a
    void setLayerType(android.view.View,int,android.graphics.Paint) -> a
android.support.v4.view.ViewCompat$GBViewCompatImpl -> android.support.v4.view.s:
    int getOverScrollMode(android.view.View) -> a
android.support.v4.view.ViewCompat$HCViewCompatImpl -> android.support.v4.view.t:
    long getFrameTime() -> a
    void setLayerType(android.view.View,int,android.graphics.Paint) -> a
android.support.v4.view.ViewCompat$ICSViewCompatImpl -> android.support.v4.view.u:
    boolean canScrollHorizontally(android.view.View,int) -> a
android.support.v4.view.ViewCompat$JBViewCompatImpl -> android.support.v4.view.v:
    void postInvalidateOnAnimation(android.view.View) -> b
    void postOnAnimation(android.view.View,java.lang.Runnable) -> a
android.support.v4.view.ViewCompat$JbMr1ViewCompatImpl -> android.support.v4.view.w:
android.support.v4.view.ViewCompat$ViewCompatImpl -> android.support.v4.view.x:
    boolean canScrollHorizontally(android.view.View,int) -> a
    int getOverScrollMode(android.view.View) -> a
    void postInvalidateOnAnimation(android.view.View) -> b
    void postOnAnimation(android.view.View,java.lang.Runnable) -> a
    void setLayerType(android.view.View,int,android.graphics.Paint) -> a
android.support.v4.view.ViewCompatGingerbread -> android.support.v4.view.y:
    int getOverScrollMode(android.view.View) -> a
android.support.v4.view.ViewCompatHC -> android.support.v4.view.z:
    long getFrameTime() -> a
    void setLayerType(android.view.View,int,android.graphics.Paint) -> a
android.support.v4.view.ViewCompatICS -> android.support.v4.view.aa:
    boolean canScrollHorizontally(android.view.View,int) -> a
android.support.v4.view.ViewCompatJB -> android.support.v4.view.ab:
    void postInvalidateOnAnimation(android.view.View) -> a
    void postOnAnimation(android.view.View,java.lang.Runnable) -> a
android.support.v4.view.ViewPager -> android.support.v4.view.ViewPager:
    int[] LAYOUT_ATTRS -> a
    java.util.Comparator COMPARATOR -> b
    android.view.animation.Interpolator sInterpolator -> c
    java.util.ArrayList mItems -> d
    android.support.v4.view.ViewPager$ItemInfo mTempItem -> e
    android.graphics.Rect mTempRect -> f
    android.support.v4.view.PagerAdapter mAdapter -> g
    int mCurItem -> h
    int mRestoredCurItem -> i
    android.os.Parcelable mRestoredAdapterState -> j
    java.lang.ClassLoader mRestoredClassLoader -> k
    android.widget.Scroller mScroller -> l
    android.support.v4.view.ViewPager$PagerObserver mObserver -> m
    int mPageMargin -> n
    android.graphics.drawable.Drawable mMarginDrawable -> o
    int mTopPageBounds -> p
    int mBottomPageBounds -> q
    float mFirstOffset -> r
    float mLastOffset -> s
    int mChildWidthMeasureSpec -> t
    int mChildHeightMeasureSpec -> u
    boolean mInLayout -> v
    boolean mScrollingCacheEnabled -> w
    boolean mPopulatePending -> x
    int mOffscreenPageLimit -> y
    boolean mIsBeingDragged -> z
    boolean mIsUnableToDrag -> A
    int mDefaultGutterSize -> B
    int mGutterSize -> C
    int mTouchSlop -> D
    float mLastMotionX -> E
    float mLastMotionY -> F
    float mInitialMotionX -> G
    float mInitialMotionY -> H
    int mActivePointerId -> I
    android.view.VelocityTracker mVelocityTracker -> J
    int mMinimumVelocity -> K
    int mMaximumVelocity -> L
    int mFlingDistance -> M
    int mCloseEnough -> N
    boolean mFakeDragging -> O
    android.support.v4.widget.EdgeEffectCompat mLeftEdge -> P
    android.support.v4.widget.EdgeEffectCompat mRightEdge -> Q
    boolean mFirstLayout -> R
    boolean mNeedCalculatePageOffsets -> S
    boolean mCalledSuper -> T
    int mDecorChildCount -> U
    android.support.v4.view.ViewPager$OnPageChangeListener mOnPageChangeListener -> V
    android.support.v4.view.ViewPager$OnPageChangeListener mInternalPageChangeListener -> W
    android.support.v4.view.ViewPager$OnAdapterChangeListener mAdapterChangeListener -> Z
    android.support.v4.view.ViewPager$PageTransformer mPageTransformer -> aa
    java.lang.reflect.Method mSetChildrenDrawingOrderEnabled -> ab
    int mDrawingOrder -> ac
    java.util.ArrayList mDrawingOrderedChildren -> ad
    android.support.v4.view.ViewPager$ViewPositionComparator sPositionComparator -> ae
    java.lang.Runnable mEndScrollRunnable -> af
    int mScrollState -> ag
    void onDetachedFromWindow() -> onDetachedFromWindow
    void setScrollState(int) -> setScrollState
    void setAdapter(android.support.v4.view.PagerAdapter) -> setAdapter
    void removeNonDecorViews() -> f
    android.support.v4.view.PagerAdapter getAdapter() -> getAdapter
    void setOnAdapterChangeListener(android.support.v4.view.ViewPager$OnAdapterChangeListener) -> setOnAdapterChangeListener
    void setCurrentItem(int) -> setCurrentItem
    void setCurrentItem(int,boolean) -> a
    int getCurrentItem() -> getCurrentItem
    void setCurrentItemInternal(int,boolean,boolean) -> a
    void setCurrentItemInternal(int,boolean,boolean,int) -> a
    void scrollToItem(int,boolean,int,boolean) -> a
    void setOnPageChangeListener(android.support.v4.view.ViewPager$OnPageChangeListener) -> setOnPageChangeListener
    void setChildrenDrawingOrderEnabledCompat(boolean) -> setChildrenDrawingOrderEnabledCompat
    int getChildDrawingOrder(int,int) -> getChildDrawingOrder
    int getOffscreenPageLimit() -> getOffscreenPageLimit
    void setOffscreenPageLimit(int) -> setOffscreenPageLimit
    void setPageMargin(int) -> setPageMargin
    int getPageMargin() -> getPageMargin
    void setPageMarginDrawable(android.graphics.drawable.Drawable) -> setPageMarginDrawable
    void setPageMarginDrawable(int) -> setPageMarginDrawable
    boolean verifyDrawable(android.graphics.drawable.Drawable) -> verifyDrawable
    void drawableStateChanged() -> drawableStateChanged
    float distanceInfluenceForSnapDuration(float) -> a
    void smoothScrollTo(int,int,int) -> a
    android.support.v4.view.ViewPager$ItemInfo addNewItem(int,int) -> a
    void dataSetChanged() -> a
    void populate() -> b
    void populate(int) -> a
    void calculatePageOffsets(android.support.v4.view.ViewPager$ItemInfo,int,android.support.v4.view.ViewPager$ItemInfo) -> a
    android.os.Parcelable onSaveInstanceState() -> onSaveInstanceState
    void onRestoreInstanceState(android.os.Parcelable) -> onRestoreInstanceState
    void addView(android.view.View,int,android.view.ViewGroup$LayoutParams) -> addView
    void removeView(android.view.View) -> removeView
    android.support.v4.view.ViewPager$ItemInfo infoForChild(android.view.View) -> a
    android.support.v4.view.ViewPager$ItemInfo infoForAnyChild(android.view.View) -> b
    android.support.v4.view.ViewPager$ItemInfo infoForPosition(int) -> b
    void onAttachedToWindow() -> onAttachedToWindow
    void onMeasure(int,int) -> onMeasure
    void onSizeChanged(int,int,int,int) -> onSizeChanged
    void recomputeScrollPosition(int,int,int,int) -> a
    void onLayout(boolean,int,int,int,int) -> onLayout
    void computeScroll() -> computeScroll
    boolean pageScrolled(int) -> d
    void onPageScrolled(int,float,int) -> a
    void completeScroll(boolean) -> a
    boolean isGutterDrag(float,float) -> a
    void enableLayers(boolean) -> b
    boolean onInterceptTouchEvent(android.view.MotionEvent) -> onInterceptTouchEvent
    boolean onTouchEvent(android.view.MotionEvent) -> onTouchEvent
    boolean performDrag(float) -> b
    android.support.v4.view.ViewPager$ItemInfo infoForCurrentScrollPosition() -> g
    int determineTargetPage(int,float,int,int) -> a
    void draw(android.graphics.Canvas) -> draw
    void onDraw(android.graphics.Canvas) -> onDraw
    void onSecondaryPointerUp(android.view.MotionEvent) -> a
    void endDrag() -> h
    void setScrollingCacheEnabled(boolean) -> setScrollingCacheEnabled
    boolean canScroll(android.view.View,boolean,int,int,int) -> a
    boolean dispatchKeyEvent(android.view.KeyEvent) -> dispatchKeyEvent
    boolean executeKeyEvent(android.view.KeyEvent) -> a
    boolean arrowScroll(int) -> c
    android.graphics.Rect getChildRectInPagerCoordinates(android.graphics.Rect,android.view.View) -> a
    boolean pageLeft() -> c
    boolean pageRight() -> d
    void addFocusables(java.util.ArrayList,int,int) -> addFocusables
    void addTouchables(java.util.ArrayList) -> addTouchables
    boolean onRequestFocusInDescendants(int,android.graphics.Rect) -> onRequestFocusInDescendants
    boolean dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent) -> dispatchPopulateAccessibilityEvent
    android.view.ViewGroup$LayoutParams generateDefaultLayoutParams() -> generateDefaultLayoutParams
    android.view.ViewGroup$LayoutParams generateLayoutParams(android.view.ViewGroup$LayoutParams) -> generateLayoutParams
    boolean checkLayoutParams(android.view.ViewGroup$LayoutParams) -> checkLayoutParams
    android.view.ViewGroup$LayoutParams generateLayoutParams(android.util.AttributeSet) -> generateLayoutParams
    int[] access$400() -> e
android.support.v4.view.ViewPager$1 -> android.support.v4.view.ac:
    int compare(android.support.v4.view.ViewPager$ItemInfo,android.support.v4.view.ViewPager$ItemInfo) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
android.support.v4.view.ViewPager$2 -> android.support.v4.view.ad:
    float getInterpolation(float) -> getInterpolation
android.support.v4.view.ViewPager$Decor -> android.support.v4.view.ae:
android.support.v4.view.ViewPager$ItemInfo -> android.support.v4.view.af:
    java.lang.Object object -> a
    int position -> b
    boolean scrolling -> c
    float widthFactor -> d
    float offset -> e
android.support.v4.view.ViewPager$LayoutParams -> android.support.v4.view.ag:
    boolean isDecor -> a
    int gravity -> b
    float widthFactor -> c
    boolean needsMeasure -> d
    int position -> e
    int childIndex -> f
android.support.v4.view.ViewPager$OnAdapterChangeListener -> android.support.v4.view.ah:
    void onAdapterChanged(android.support.v4.view.PagerAdapter,android.support.v4.view.PagerAdapter) -> a
android.support.v4.view.ViewPager$OnPageChangeListener -> android.support.v4.view.ai:
    void onPageScrolled(int,float,int) -> a
    void onPageSelected(int) -> a
    void onPageScrollStateChanged(int) -> b
android.support.v4.view.ViewPager$PageTransformer -> android.support.v4.view.aj:
    void transformPage(android.view.View,float) -> a
android.support.v4.view.ViewPager$PagerObserver -> android.support.v4.view.ak:
    android.support.v4.view.ViewPager this$0 -> a
    void onChanged() -> onChanged
    void onInvalidated() -> onInvalidated
android.support.v4.view.ViewPager$SavedState -> android.support.v4.view.ViewPager$SavedState:
    int position -> a
    android.os.Parcelable adapterState -> b
    java.lang.ClassLoader loader -> c
    android.os.Parcelable$Creator CREATOR -> CREATOR
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
    java.lang.String toString() -> toString
android.support.v4.view.ViewPager$SavedState$1 -> android.support.v4.view.al:
    android.support.v4.view.ViewPager$SavedState createFromParcel(android.os.Parcel,java.lang.ClassLoader) -> b
    android.support.v4.view.ViewPager$SavedState[] newArray(int) -> b
    java.lang.Object[] newArray(int) -> a
    java.lang.Object createFromParcel(android.os.Parcel,java.lang.ClassLoader) -> a
android.support.v4.view.ViewPager$ViewPositionComparator -> android.support.v4.view.am:
    int compare(android.view.View,android.view.View) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
android.support.v4.widget.EdgeEffectCompat -> android.support.v4.d.a:
    java.lang.Object mEdgeEffect -> a
    android.support.v4.widget.EdgeEffectCompat$EdgeEffectImpl IMPL -> b
    void setSize(int,int) -> a
    boolean isFinished() -> a
    void finish() -> b
    boolean onPull(float) -> a
    boolean onRelease() -> c
    boolean draw(android.graphics.Canvas) -> a
android.support.v4.widget.EdgeEffectCompat$BaseEdgeEffectImpl -> android.support.v4.d.b:
    void setSize(java.lang.Object,int,int) -> a
    boolean isFinished(java.lang.Object) -> a
    void finish(java.lang.Object) -> b
    boolean onPull(java.lang.Object,float) -> a
    boolean onRelease(java.lang.Object) -> c
    boolean draw(java.lang.Object,android.graphics.Canvas) -> a
android.support.v4.widget.EdgeEffectCompat$EdgeEffectIcsImpl -> android.support.v4.d.c:
    void setSize(java.lang.Object,int,int) -> a
    boolean isFinished(java.lang.Object) -> a
    void finish(java.lang.Object) -> b
    boolean onPull(java.lang.Object,float) -> a
    boolean onRelease(java.lang.Object) -> c
    boolean draw(java.lang.Object,android.graphics.Canvas) -> a
android.support.v4.widget.EdgeEffectCompat$EdgeEffectImpl -> android.support.v4.d.d:
    void setSize(java.lang.Object,int,int) -> a
    boolean isFinished(java.lang.Object) -> a
    void finish(java.lang.Object) -> b
    boolean onPull(java.lang.Object,float) -> a
    boolean onRelease(java.lang.Object) -> c
    boolean draw(java.lang.Object,android.graphics.Canvas) -> a
android.support.v4.widget.EdgeEffectCompatIcs -> android.support.v4.d.e:
    void setSize(java.lang.Object,int,int) -> a
    boolean isFinished(java.lang.Object) -> a
    void finish(java.lang.Object) -> b
    boolean onPull(java.lang.Object,float) -> a
    boolean onRelease(java.lang.Object) -> c
    boolean draw(java.lang.Object,android.graphics.Canvas) -> a
com.gutabi.bypass.BypassApplication -> com.gutabi.bypass.a:
    com.gutabi.capsloc.ui.Image logo -> a
    com.gutabi.capsloc.ui.Image copyright -> b
    com.gutabi.bypass.level.LevelDB tutorialLevelDB -> c
    com.gutabi.bypass.level.LevelDB episode1LevelDB -> d
    com.gutabi.bypass.level.LevelDB episode2LevelDB -> e
    com.gutabi.bypass.BypassPlatform bypassPlatform -> f
    com.gutabi.bypass.BypassApplication BYPASSAPP -> g
    void create(com.gutabi.bypass.BypassPlatform) -> a
com.gutabi.bypass.BypassPlatform -> com.gutabi.bypass.b:
    void loadScores(com.gutabi.bypass.level.LevelDB) -> a
    void saveScore(com.gutabi.bypass.level.LevelDB,com.gutabi.bypass.level.Level) -> a
    void clearScores(com.gutabi.bypass.level.LevelDB) -> b
com.gutabi.bypass.android.ActivityState -> com.gutabi.bypass.android.a:
    com.gutabi.bypass.android.ActivityState CREATE -> a
    com.gutabi.bypass.android.ActivityState DESTROY -> b
    com.gutabi.bypass.android.ActivityState START -> c
    com.gutabi.bypass.android.ActivityState STOP -> d
    com.gutabi.bypass.android.ActivityState PAUSE -> e
    com.gutabi.bypass.android.ActivityState RESUME -> f
    com.gutabi.bypass.android.ActivityState RESTART -> g
    com.gutabi.bypass.android.ActivityState[] ENUM$VALUES -> h
    com.gutabi.bypass.android.ActivityState[] values() -> values
    com.gutabi.bypass.android.ActivityState valueOf(java.lang.String) -> valueOf
com.gutabi.bypass.android.BypassActivity -> com.gutabi.bypass.android.b:
    com.gutabi.bypass.android.BypassView v -> a
    com.gutabi.bypass.android.ActivityState state -> b
    java.lang.String name -> c
    void onCreate(android.os.Bundle) -> onCreate
    void onDestroy() -> onDestroy
    void onStart() -> onStart
    void onStop() -> onStop
    void onRestart() -> onRestart
    void onResume() -> onResume
    void onPause() -> onPause
    void onSurfaceChanged(int,int) -> a
    void onSaveInstanceState(android.os.Bundle) -> onSaveInstanceState
    void onRestoreInstanceState(android.os.Bundle) -> onRestoreInstanceState
com.gutabi.bypass.android.BypassAndroidPlatform -> com.gutabi.bypass.android.c:
    com.gutabi.bypass.android.BypassActivity CURRENTACTIVITY -> a
    android.content.res.Resources resources -> b
    com.gutabi.bypass.android.ResourceImpl visitorFontResource -> c
    android.graphics.Paint visitorPlain36 -> d
    android.graphics.Paint visitorPlain16 -> e
    android.graphics.Paint visitorPlain48 -> f
    android.graphics.Paint visitorPlain72 -> g
    android.graphics.Paint imgPaint -> h
    java.util.Map fontBoundsCache -> i
    boolean $assertionsDisabled -> j
    com.gutabi.capsloc.ui.paint.RenderingContext createRenderingContext() -> a
    void setRenderingContextFields1(com.gutabi.capsloc.ui.paint.RenderingContext,java.lang.Object) -> a
    void setRenderingContextFields2(com.gutabi.capsloc.ui.paint.RenderingContext,java.lang.Object,java.lang.Object) -> a
    android.graphics.Paint getFontPaint(com.gutabi.capsloc.Resource,com.gutabi.capsloc.ui.paint.FontStyle,int) -> a
    com.gutabi.capsloc.geom.AABB bounds(java.lang.String,com.gutabi.capsloc.Resource,com.gutabi.capsloc.ui.paint.FontStyle,int) -> a
    com.gutabi.capsloc.ui.Image createImage(int,int) -> a
    com.gutabi.capsloc.ui.Image createTransparentImage(int,int) -> b
    com.gutabi.capsloc.ui.Image readImage(com.gutabi.capsloc.Resource) -> a
    com.gutabi.capsloc.ui.PlatformContentPane createPlatformContentPane() -> b
    void setupAppScreen(java.lang.Object[]) -> a
    void showAppScreen() -> c
    com.gutabi.capsloc.Resource fontResource(java.lang.String) -> a
    java.io.InputStream openResourceInputStream(com.gutabi.capsloc.Resource) -> b
    void finishAction() -> d
    void loadScores(com.gutabi.bypass.level.LevelDB) -> a
    void saveScore(com.gutabi.bypass.level.LevelDB,com.gutabi.bypass.level.Level) -> a
    void clearScores(com.gutabi.bypass.level.LevelDB) -> b
    long monotonicClockMillis() -> e
    com.gutabi.capsloc.geom.GeometryPath createGeometryPath() -> f
com.gutabi.bypass.android.BypassView -> com.gutabi.bypass.android.BypassView:
    com.gutabi.bypass.android.BypassActivity activity -> a
    android.view.SurfaceHolder holder -> b
    boolean surfaceValid -> c
    com.gutabi.capsloc.ui.Paintable paintable -> d
    android.graphics.Paint paint -> e
    com.gutabi.capsloc.ui.paint.RenderingContext ctxt -> f
    void surfaceCreated(android.view.SurfaceHolder) -> surfaceCreated
    void surfaceDestroyed(android.view.SurfaceHolder) -> surfaceDestroyed
    void surfaceChanged(android.view.SurfaceHolder,int,int,int) -> surfaceChanged
    boolean onTouchEvent(android.view.MotionEvent) -> onTouchEvent
    void doDraw(android.graphics.Canvas) -> a
com.gutabi.bypass.android.R -> com.gutabi.bypass.android.d:
com.gutabi.bypass.android.R$id -> com.gutabi.bypass.android.e:
    int view_levelmenu -> view_levelmenu
    int view_bypassworld -> view_bypassworld
    int btn_clear_scores -> btn_clear_scores
    int btn_reset_level -> btn_reset_level
    int btn_toggle_info -> btn_toggle_info
com.gutabi.bypass.android.R$layout -> com.gutabi.bypass.android.f:
    int activity_bypassworld -> activity_bypassworld
    int activity_levelmenu -> activity_levelmenu
com.gutabi.bypass.android.R$menu -> com.gutabi.bypass.android.g:
    int world_context_menu -> world_context_menu
    int levelmenu_context_menu -> levelmenu_context_menu
com.gutabi.bypass.android.ResourceImpl -> com.gutabi.bypass.android.h:
    int resId -> a
    com.gutabi.bypass.android.ResourceType resType -> b
    android.graphics.Typeface face -> c
com.gutabi.bypass.android.ResourceType -> com.gutabi.bypass.android.i:
    com.gutabi.bypass.android.ResourceType DRAWABLE -> a
    com.gutabi.bypass.android.ResourceType RAW -> b
    com.gutabi.bypass.android.ResourceType[] ENUM$VALUES -> c
    com.gutabi.bypass.android.ResourceType[] values() -> values
    com.gutabi.bypass.android.ResourceType valueOf(java.lang.String) -> valueOf
com.gutabi.bypass.android.full.BypassAndroidFullPlatform -> com.gutabi.bypass.android.full.a:
    com.gutabi.capsloc.Resource imageResource(java.lang.String) -> b
    com.gutabi.capsloc.Resource levelDBResource(java.lang.String) -> c
    java.lang.String resourceName(com.gutabi.capsloc.Resource) -> c
    void action(java.lang.Class,java.lang.Object[]) -> a
com.gutabi.bypass.android.full.MainMenuActivity -> com.gutabi.bypass.android.full.MainMenuActivity:
    void onCreate(android.os.Bundle) -> onCreate
    void onStart() -> onStart
    void onStop() -> onStop
    void onResume() -> onResume
    void onSurfaceChanged(int,int) -> a
    void onPause() -> onPause
com.gutabi.bypass.android.geom.GeometryPathImpl -> com.gutabi.bypass.android.a.a:
    android.graphics.Path p -> a
    void reset() -> a
    void add(com.gutabi.capsloc.geom.Circle) -> a
    void add(com.gutabi.capsloc.geom.OBB) -> a
    void add(com.gutabi.capsloc.geom.MutableOBB) -> a
    void add(com.gutabi.capsloc.geom.Triangle) -> a
    void add(com.gutabi.capsloc.geom.MutablePolygon) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.bypass.android.level.BypassWorldActivity -> com.gutabi.bypass.android.level.BypassWorldActivity:
    void onCreate(android.os.Bundle) -> onCreate
    void onStart() -> onStart
    void onStop() -> onStop
    void onResume() -> onResume
    void onSurfaceChanged(int,int) -> a
    void onPause() -> onPause
    void onSaveInstanceState(android.os.Bundle) -> onSaveInstanceState
    boolean onCreateOptionsMenu(android.view.Menu) -> onCreateOptionsMenu
    boolean onOptionsItemSelected(android.view.MenuItem) -> onOptionsItemSelected
com.gutabi.bypass.android.menu.LevelMenuActivity -> com.gutabi.bypass.android.menu.LevelMenuActivity:
    void onCreate(android.os.Bundle) -> onCreate
    void onStart() -> onStart
    void onStop() -> onStop
    void onResume() -> onResume
    void onSurfaceChanged(int,int) -> a
    void onPause() -> onPause
    void onSaveInstanceState(android.os.Bundle) -> onSaveInstanceState
    boolean onCreateOptionsMenu(android.view.Menu) -> onCreateOptionsMenu
    boolean onOptionsItemSelected(android.view.MenuItem) -> onOptionsItemSelected
com.gutabi.bypass.android.ui.ImageImpl -> com.gutabi.bypass.android.b.a:
    android.graphics.Bitmap b -> a
    int getWidth() -> a
    int getHeight() -> b
com.gutabi.bypass.android.ui.PlatformContentPaneImpl -> com.gutabi.bypass.android.b.b:
    com.gutabi.bypass.android.BypassView v -> a
    void repaint() -> a
com.gutabi.bypass.android.ui.paint.RenderingContextImpl -> com.gutabi.bypass.android.b.a.a:
    float RAD -> a
    android.graphics.Canvas canvas -> b
    android.graphics.Paint paint -> c
    android.graphics.Rect srcRect -> d
    android.graphics.RectF destRect -> e
    boolean $assertionsDisabled -> f
    int[] $SWITCH_TABLE$com$gutabi$capsloc$ui$paint$Cap -> h
    int[] $SWITCH_TABLE$com$gutabi$capsloc$ui$paint$Join -> i
    void rotate(double) -> a
    void paintImage(com.gutabi.capsloc.ui.Image,double,double,double,double,double,int,int,int,int) -> a
    void paintImage(com.gutabi.capsloc.ui.Image,int,int,int,int,int,int,int,int) -> a
    void dispose() -> a
    void setFont(com.gutabi.capsloc.Resource,com.gutabi.capsloc.ui.paint.FontStyle,int) -> a
    void setXORMode(com.gutabi.capsloc.ui.paint.Color) -> a
    void clearXORMode() -> b
    void pushTransform() -> c
    void popTransform() -> d
    void pushClip() -> e
    void popClip() -> f
    void drawAABB(com.gutabi.capsloc.geom.AABB) -> a
    void paintAABB(com.gutabi.capsloc.geom.AABB) -> b
    void drawAABB(com.gutabi.capsloc.geom.MutableAABB) -> a
    void paintPath(com.gutabi.capsloc.geom.GeometryPath) -> a
    void drawLine(com.gutabi.capsloc.geom.Line) -> a
    void paintCircle(com.gutabi.capsloc.geom.Circle) -> a
    void scale(double) -> b
    void setColor(com.gutabi.capsloc.ui.paint.Color) -> b
    void translate(double,double) -> a
    void clip(com.gutabi.capsloc.geom.AABB) -> c
    void setAlpha(double) -> c
    void paintString(double,double,double,java.lang.String) -> a
    void setStroke(double,com.gutabi.capsloc.ui.paint.Cap,com.gutabi.capsloc.ui.paint.Join) -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$ui$paint$Cap() -> g
    int[] $SWITCH_TABLE$com$gutabi$capsloc$ui$paint$Join() -> h
com.gutabi.bypass.level.BypassCar -> com.gutabi.bypass.a.a:
    char boardLetter -> a
    double coastingVel -> b
    double coastingAcceleration -> c
    boolean $assertionsDisabled -> d
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum -> M
    com.gutabi.bypass.level.BypassCar createCar(com.gutabi.capsloc.world.World,com.gutabi.capsloc.world.sprites.CarSheet$CarType,int,char) -> a
    boolean preStep(double) -> a
    void setCoastingVelFromDrag(com.gutabi.capsloc.math.Point,long,boolean) -> a
    void clearCoastingVel() -> a
    void fakeCoastingStep(double) -> b
    boolean postStep(double) -> c
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum() -> b
com.gutabi.bypass.level.BypassCarTool -> com.gutabi.bypass.a.b:
    com.gutabi.bypass.level.BypassCar car -> a
    com.gutabi.capsloc.math.Point lastPressP -> b
    com.gutabi.capsloc.math.Point lastPanelPressP -> c
    com.gutabi.capsloc.math.Point prevDragP -> d
    com.gutabi.capsloc.math.Point curDragP -> e
    com.gutabi.capsloc.math.Point dragVector -> f
    long prevDragMillis -> g
    long curDragMillis -> h
    long dragTimeStepMillis -> i
    com.gutabi.capsloc.math.Point lastPanelDragP -> j
    com.gutabi.capsloc.math.Point penPanelDragP -> k
    boolean $assertionsDisabled -> l
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum -> n
    void pressed(com.gutabi.capsloc.ui.InputEvent) -> a
    void released(com.gutabi.capsloc.ui.InputEvent) -> b
    void determineCoasting(com.gutabi.capsloc.world.graph.GraphPositionPathPosition,com.gutabi.capsloc.world.graph.GraphPositionPathPosition,boolean) -> a
    void dragged(com.gutabi.capsloc.ui.InputEvent) -> c
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum() -> a
com.gutabi.bypass.level.BypassDriver -> com.gutabi.bypass.a.c:
    boolean $assertionsDisabled -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum -> b
    void postStep(double) -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum() -> a
com.gutabi.bypass.level.BypassWorld -> com.gutabi.bypass.a.d:
    java.util.concurrent.locks.Lock lock -> a
    boolean rendered -> b
    com.gutabi.bypass.level.BypassWorld BYPASSWORLD -> c
    com.gutabi.bypass.level.LevelDB levelDB -> d
    com.gutabi.bypass.level.Level curLevel -> e
    com.gutabi.bypass.level.WinnerMenu winnerMenu -> f
    com.gutabi.capsloc.world.graph.BypassBoard bypassBoard -> g
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Side -> C
    boolean $assertionsDisabled -> h
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Axis -> D
    void create(com.gutabi.bypass.level.LevelDB,int) -> a
    void start() -> a
    void stop() -> b
    void resume() -> c
    void surfaceChanged(int,int) -> a
    void pause() -> a_
    void reset() -> e
    com.gutabi.bypass.level.BypassWorld createBypassWorld(com.gutabi.bypass.level.LevelDB,int) -> b
    void addBypassCars(com.gutabi.capsloc.world.graph.BypassBoard) -> a
    void addNewCar(com.gutabi.capsloc.world.graph.BypassBoard,int,int,com.gutabi.capsloc.world.graph.Axis,com.gutabi.capsloc.world.sprites.CarSheet$CarType,int,char) -> a
    com.gutabi.capsloc.ui.Menu getMenu() -> f
    void handlePanning(com.gutabi.capsloc.world.cars.Car,com.gutabi.capsloc.math.Point) -> a
    void winner() -> g
    void panelPostDisplay(int,int) -> b
    void render_worldPanel() -> h
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Side() -> i
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Axis() -> j
com.gutabi.bypass.level.Level -> com.gutabi.bypass.a.e:
    int index -> a
    char[][] ini -> b
    int requiredMoves -> c
    int userMoves -> d
    long userTime -> e
    long userStartTime -> f
    boolean isWon -> g
    java.lang.String grade -> h
com.gutabi.bypass.level.LevelDB -> com.gutabi.bypass.a.f:
    java.lang.String name -> a
    int firstUnwon -> b
    com.gutabi.capsloc.math.Point loc -> c
    java.util.Map levelMap -> g
    com.gutabi.capsloc.Resource res -> d
    int levelCount -> e
    boolean $assertionsDisabled -> f
    void setFirstUnwon() -> a
    com.gutabi.bypass.level.Level getLevel(int) -> a
    void clearLevels() -> b
com.gutabi.bypass.level.WinnerMenu -> com.gutabi.bypass.a.g:
    boolean ready -> a
    void action() -> a
    void postDisplay(int,int) -> a
com.gutabi.bypass.level.WinnerMenu$1 -> com.gutabi.bypass.a.h:
    com.gutabi.bypass.level.WinnerMenu this$0 -> a
    void action() -> a
com.gutabi.bypass.level.WinnerMenu$2 -> com.gutabi.bypass.a.i:
    com.gutabi.bypass.level.WinnerMenu this$0 -> a
    void action() -> a
com.gutabi.bypass.level.WinnerMenu$3 -> com.gutabi.bypass.a.j:
    com.gutabi.bypass.level.WinnerMenu this$0 -> a
    void action() -> a
com.gutabi.bypass.level.WinnerMenu$4 -> com.gutabi.bypass.a.k:
    com.gutabi.bypass.level.WinnerMenu this$0 -> a
    void action() -> a
com.gutabi.bypass.level.WinnerMenu$5 -> com.gutabi.bypass.a.l:
    com.gutabi.bypass.level.WinnerMenu this$0 -> a
    void action() -> a
com.gutabi.bypass.menu.BypassMenu -> com.gutabi.bypass.b.a:
    com.gutabi.bypass.menu.BypassMenu BYPASSMENU -> a
    void create() -> a
    void start() -> b
    void stop() -> c
    com.gutabi.capsloc.ui.Menu getMenu() -> f
    double getTime() -> d
    boolean integrate(double) -> a
com.gutabi.bypass.menu.BypassMenuPanel -> com.gutabi.bypass.b.b:
    void postDisplay(int,int) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.bypass.menu.LevelMenu -> com.gutabi.bypass.b.c:
    com.gutabi.bypass.level.LevelDB levelDB -> b
    boolean showInfo -> c
    java.util.concurrent.atomic.AtomicBoolean simThreadTrigger -> d
    java.lang.Thread simThread -> e
    void resume() -> e
    void surfaceChanged(int,int) -> b
    void pause() -> g
com.gutabi.bypass.menu.LevelMenu$1 -> com.gutabi.bypass.b.d:
    int val$ii -> n
    void action() -> a
com.gutabi.bypass.menu.LevelMenuItem -> com.gutabi.bypass.b.e:
    int index -> a
    void render() -> b
com.gutabi.bypass.menu.MainMenu -> com.gutabi.bypass.b.f:
    java.util.concurrent.atomic.AtomicBoolean simThreadTrigger -> b
    java.lang.Thread simThread -> c
    void resume() -> e
    void surfaceChanged(int,int) -> b
    void pause() -> g
com.gutabi.bypass.menu.MainMenu$1 -> com.gutabi.bypass.b.g:
    com.gutabi.bypass.menu.MainMenu this$0 -> a
    void action() -> a
com.gutabi.bypass.menu.MainMenu$2 -> com.gutabi.bypass.b.h:
    com.gutabi.bypass.menu.MainMenu this$0 -> a
    void action() -> a
com.gutabi.bypass.menu.MainMenu$3 -> com.gutabi.bypass.b.i:
    com.gutabi.bypass.menu.MainMenu this$0 -> a
    void action() -> a
com.gutabi.capsloc.AppScreen -> com.gutabi.a.a:
    com.gutabi.capsloc.ui.ContentPane contentPane -> a
    void postDisplay(int,int) -> a
com.gutabi.capsloc.CapslocApplication -> com.gutabi.a.b:
    com.gutabi.capsloc.world.sprites.Sheet carSheet -> h
    com.gutabi.capsloc.world.sprites.Sheet spriteSheet -> i
    com.gutabi.capsloc.AppScreen appScreen -> j
    com.gutabi.capsloc.Model model -> k
    com.gutabi.capsloc.Tool tool -> l
    com.gutabi.capsloc.Platform platform -> m
    boolean NORMALCAR -> n
    boolean FASTCAR -> o
    boolean REALLYCAR -> p
    boolean TRUCK -> q
    boolean FPS_DRAW -> r
    boolean STOPSIGN_DRAW -> s
    boolean CARTEXTURE_DRAW -> t
    boolean EXPLOSIONS_DRAW -> u
    boolean DEBUG_DRAW -> v
    java.util.Random RANDOM -> w
    com.gutabi.capsloc.CapslocApplication APP -> x
    void setAppScreen(com.gutabi.capsloc.AppScreen) -> a
com.gutabi.capsloc.Entity -> com.gutabi.a.c:
    boolean isUserDeleteable() -> c
    void preStart() -> d
    boolean preStep(double) -> a
    boolean postStep(double) -> c
com.gutabi.capsloc.Integratable -> com.gutabi.a.d:
    boolean integrate(double) -> a
    double getTime() -> d
com.gutabi.capsloc.Model -> com.gutabi.a.e:
    com.gutabi.capsloc.ui.Menu getMenu() -> f
com.gutabi.capsloc.Platform -> com.gutabi.a.f:
    com.gutabi.capsloc.ui.paint.RenderingContext createRenderingContext() -> a
    void setRenderingContextFields1(com.gutabi.capsloc.ui.paint.RenderingContext,java.lang.Object) -> a
    void setRenderingContextFields2(com.gutabi.capsloc.ui.paint.RenderingContext,java.lang.Object,java.lang.Object) -> a
    com.gutabi.capsloc.geom.AABB bounds(java.lang.String,com.gutabi.capsloc.Resource,com.gutabi.capsloc.ui.paint.FontStyle,int) -> a
    com.gutabi.capsloc.ui.Image readImage(com.gutabi.capsloc.Resource) -> a
    com.gutabi.capsloc.ui.Image createImage(int,int) -> a
    com.gutabi.capsloc.ui.Image createTransparentImage(int,int) -> b
    com.gutabi.capsloc.ui.PlatformContentPane createPlatformContentPane() -> b
    void setupAppScreen(java.lang.Object[]) -> a
    void showAppScreen() -> c
    com.gutabi.capsloc.Resource imageResource(java.lang.String) -> b
    com.gutabi.capsloc.Resource fontResource(java.lang.String) -> a
    com.gutabi.capsloc.Resource levelDBResource(java.lang.String) -> c
    java.lang.String resourceName(com.gutabi.capsloc.Resource) -> c
    java.io.InputStream openResourceInputStream(com.gutabi.capsloc.Resource) -> b
    com.gutabi.capsloc.geom.GeometryPath createGeometryPath() -> f
    void action(java.lang.Class,java.lang.Object[]) -> a
    void finishAction() -> d
    long monotonicClockMillis() -> e
com.gutabi.capsloc.Resource -> com.gutabi.a.g:
com.gutabi.capsloc.SimulationRunnable -> com.gutabi.a.h:
    java.util.concurrent.atomic.AtomicBoolean trigger -> a
    void run() -> run
com.gutabi.capsloc.Tool -> com.gutabi.a.i:
    void pressed(com.gutabi.capsloc.ui.InputEvent) -> a
    void released(com.gutabi.capsloc.ui.InputEvent) -> b
    void dragged(com.gutabi.capsloc.ui.InputEvent) -> c
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.geom.AABB -> com.gutabi.a.a.a:
    com.gutabi.capsloc.math.Dim dim -> a
    double x -> b
    double y -> c
    double width -> d
    double height -> e
    double brX -> f
    double brY -> g
    double centerX -> h
    double centerY -> i
    com.gutabi.capsloc.math.Point n01 -> j
    com.gutabi.capsloc.math.Point n12 -> k
    double[] n01Projection -> l
    double[] n12Projection -> m
    com.gutabi.capsloc.geom.Line p0p1Line -> n
    com.gutabi.capsloc.geom.Line p1p2Line -> o
    com.gutabi.capsloc.geom.Line p2p3Line -> p
    com.gutabi.capsloc.geom.Line p3p0Line -> q
    int hash -> r
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    com.gutabi.capsloc.geom.AABB getAABB() -> a
    void project(com.gutabi.capsloc.math.Point,double[]) -> a
    com.gutabi.capsloc.math.Point closestCornerTo(com.gutabi.capsloc.math.Point) -> a
    void computeProjections() -> h
    com.gutabi.capsloc.math.Point getN01() -> b
    com.gutabi.capsloc.math.Point getN12() -> c
    void projectN01(double[]) -> a
    void projectN12(double[]) -> b
    com.gutabi.capsloc.geom.Line getP0P1Line() -> d
    com.gutabi.capsloc.geom.Line getP1P2Line() -> e
    com.gutabi.capsloc.geom.Line getP2P3Line() -> f
    com.gutabi.capsloc.geom.Line getP3P0Line() -> g
    boolean hitTest(com.gutabi.capsloc.math.Point) -> b
    com.gutabi.capsloc.geom.AABB union(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.AABB) -> a
    com.gutabi.capsloc.geom.AABB intersection(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.AABB) -> b
    void draw(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
com.gutabi.capsloc.geom.Capsule -> com.gutabi.a.a.b:
    com.gutabi.capsloc.geom.Circle ac -> a
    com.gutabi.capsloc.geom.Circle bc -> b
    com.gutabi.capsloc.geom.OBB middle -> c
    com.gutabi.capsloc.math.Point a -> d
    com.gutabi.capsloc.math.Point b -> e
    double r -> f
    com.gutabi.capsloc.math.Point aUp -> g
    com.gutabi.capsloc.math.Point aDown -> h
    com.gutabi.capsloc.math.Point bUp -> i
    com.gutabi.capsloc.math.Point bDown -> j
    com.gutabi.capsloc.geom.Line debugNormalLine -> m
    com.gutabi.capsloc.geom.Line debugSkeletonLine -> n
    com.gutabi.capsloc.geom.AABB aabb -> k
    com.gutabi.capsloc.geom.Line abUp -> o
    com.gutabi.capsloc.geom.Line baDown -> p
    com.gutabi.capsloc.geom.GeometryPath path -> q
    int hash -> r
    boolean $assertionsDisabled -> l
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    com.gutabi.capsloc.math.Point getPoint(double) -> a
    double findSkeletonIntersection(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> a
    com.gutabi.capsloc.geom.Line getABUp() -> a
    com.gutabi.capsloc.geom.Line getBADown() -> b
    void drawSkeleton(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.geom.CapsuleSequence -> com.gutabi.a.a.c:
    java.util.List caps -> a
    int capsuleCount -> b
    double radius -> c
    com.gutabi.capsloc.geom.AABB aabb -> d
    com.gutabi.capsloc.geom.GeometryPath path -> e
    boolean $assertionsDisabled -> f
    com.gutabi.capsloc.geom.Capsule getCapsule(int) -> a
    double getRadius() -> a
    com.gutabi.capsloc.math.Point getPoint(int) -> b
    com.gutabi.capsloc.math.Point getPoint(int,double) -> a
    int capsuleCount() -> b
    int pointCount() -> c
    com.gutabi.capsloc.geom.Circle getStart() -> d
    com.gutabi.capsloc.geom.CapsuleSequence subsequence(int) -> c
    void capseq(int,com.gutabi.capsloc.geom.MutableCapsuleSequence) -> a
    com.gutabi.capsloc.geom.AABB getAABB() -> e
    com.gutabi.capsloc.geom.CapsuleSequencePosition findSkeletonIntersection(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> a
    com.gutabi.capsloc.geom.CapsuleSequencePosition findClosestStrokePosition(com.gutabi.capsloc.math.Point,double) -> a
    double closestParam(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.geom.Capsule) -> a
    boolean intersect(java.lang.Object) -> a
    boolean intersectA(com.gutabi.capsloc.geom.AABB) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void drawSkeleton(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
com.gutabi.capsloc.geom.CapsuleSequencePosition -> com.gutabi.a.a.d:
    com.gutabi.capsloc.geom.CapsuleSequence seq -> a
    int index -> b
    double param -> c
    com.gutabi.capsloc.math.Point p -> d
com.gutabi.capsloc.geom.CapsuleSequenceSweepEvent -> com.gutabi.a.a.e:
    com.gutabi.capsloc.geom.Circle circle -> a
    boolean $assertionsDisabled -> b
com.gutabi.capsloc.geom.Circle -> com.gutabi.a.a.f:
    com.gutabi.capsloc.math.Point center -> a
    double radius -> b
    com.gutabi.capsloc.geom.AABB aabb -> c
    int hash -> e
    boolean $assertionsDisabled -> d
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    void project(com.gutabi.capsloc.math.Point,double[]) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.geom.CompoundShape -> com.gutabi.a.a.g:
    boolean intersect(java.lang.Object) -> a
com.gutabi.capsloc.geom.CubicCurve -> com.gutabi.a.a.h:
    com.gutabi.capsloc.math.Point p0 -> a
    com.gutabi.capsloc.math.Point c0 -> b
    com.gutabi.capsloc.math.Point c1 -> c
    com.gutabi.capsloc.math.Point p1 -> d
    com.gutabi.capsloc.math.Point point(double) -> a
    java.util.List skeleton() -> a
com.gutabi.capsloc.geom.Geom -> com.gutabi.a.a.i:
    com.gutabi.capsloc.math.Point times(double[][],com.gutabi.capsloc.math.Point) -> a
    com.gutabi.capsloc.math.Point rotateAndAdd(double,double,double,com.gutabi.capsloc.math.Point) -> a
    int halfPlane(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> a
    com.gutabi.capsloc.geom.OBB localToWorld(com.gutabi.capsloc.geom.AABB,double,com.gutabi.capsloc.math.Point) -> a
    void localToWorld(com.gutabi.capsloc.geom.AABB,double,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.geom.MutableOBB) -> a
    void localToWorldAndTakeAABB(com.gutabi.capsloc.geom.AABB,double,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.geom.MutableAABB) -> a
com.gutabi.capsloc.geom.GeometryPath -> com.gutabi.a.a.j:
    void reset() -> a
    void add(com.gutabi.capsloc.geom.Circle) -> a
    void add(com.gutabi.capsloc.geom.OBB) -> a
    void add(com.gutabi.capsloc.geom.MutableOBB) -> a
    void add(com.gutabi.capsloc.geom.Triangle) -> a
    void add(com.gutabi.capsloc.geom.MutablePolygon) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.geom.Line -> com.gutabi.a.a.k:
    com.gutabi.capsloc.math.Point p0 -> a
    com.gutabi.capsloc.math.Point p1 -> b
    com.gutabi.capsloc.math.Point n01 -> c
    double[] n01Projection -> d
    int hash -> f
    boolean rightAngle -> e
    int hashCode() -> hashCode
    com.gutabi.capsloc.math.Point getN01() -> a
    void computeN01() -> b
    void computeProjections() -> c
    void project(com.gutabi.capsloc.math.Point,double[]) -> a
    void projectN01(double[]) -> a
    void draw(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.geom.MutableAABB -> com.gutabi.a.a.l:
    double x -> a
    double y -> b
    double width -> c
    double height -> d
    com.gutabi.capsloc.math.Point n01 -> e
    com.gutabi.capsloc.math.Point n12 -> f
    double[] n01Projection -> h
    double[] n12Projection -> i
    boolean $assertionsDisabled -> g
    void reset() -> a
    void setShape(double,double,double,double) -> a
    com.gutabi.capsloc.geom.AABB copy() -> b
    void union(com.gutabi.capsloc.geom.AABB) -> a
    boolean completelyWithin(com.gutabi.capsloc.geom.AABB) -> b
    double fractionWithin(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.AABB) -> a
    void project(com.gutabi.capsloc.math.Point,double[]) -> a
    com.gutabi.capsloc.math.Point getN01() -> c
    com.gutabi.capsloc.math.Point getN12() -> d
    void projectN01(double[]) -> a
    void projectN12(double[]) -> b
    void computeProjections() -> e
    void draw(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.geom.MutableCapsuleSequence -> com.gutabi.a.a.m:
    java.util.List caps -> a
    double radius -> b
    com.gutabi.capsloc.geom.MutableAABB aabb -> c
    boolean $assertionsDisabled -> d
    void setCapSeq(java.util.List) -> a
    com.gutabi.capsloc.math.Point getPoint(int,double) -> a
    double getRadius() -> a
    com.gutabi.capsloc.geom.Capsule getCapsule(int) -> a
    com.gutabi.capsloc.geom.Circle getStart() -> b
com.gutabi.capsloc.geom.MutableOBB -> com.gutabi.a.a.n:
    com.gutabi.capsloc.math.Point center -> a
    double a -> b
    double xExtant -> c
    double yExtant -> d
    com.gutabi.capsloc.math.Point p0 -> e
    com.gutabi.capsloc.math.Point p1 -> f
    com.gutabi.capsloc.math.Point p2 -> g
    com.gutabi.capsloc.math.Point p3 -> h
    com.gutabi.capsloc.math.Point n01 -> r
    com.gutabi.capsloc.math.Point n12 -> s
    double[] n01Projection -> i
    double[] n12Projection -> j
    com.gutabi.capsloc.geom.Line p0p1Line -> k
    com.gutabi.capsloc.geom.Line p1p2Line -> l
    com.gutabi.capsloc.geom.Line p2p3Line -> m
    com.gutabi.capsloc.geom.Line p3p0Line -> n
    boolean rightAngle -> o
    com.gutabi.capsloc.geom.MutableAABB aabb -> p
    int hash -> t
    boolean $assertionsDisabled -> q
    void setShape(com.gutabi.capsloc.math.Point,double,double,double) -> a
    void copy(com.gutabi.capsloc.geom.MutableOBB) -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    void computeProjections() -> c
    void computeN01() -> d
    void computeN12() -> e
    com.gutabi.capsloc.math.Point getN01() -> a
    com.gutabi.capsloc.math.Point getN12() -> b
    boolean hitTest(com.gutabi.capsloc.math.Point) -> a
    com.gutabi.capsloc.math.Point closestCornerTo(com.gutabi.capsloc.math.Point) -> b
    void project(com.gutabi.capsloc.math.Point,double[]) -> a
    void projectN01(double[]) -> a
    void projectN12(double[]) -> b
com.gutabi.capsloc.geom.MutablePolygon -> com.gutabi.a.a.o:
    double[][] pts -> a
    void setPoints(double,double,double,double,double,double,double,double) -> a
com.gutabi.capsloc.geom.MutableSweptOBB -> com.gutabi.a.a.p:
    com.gutabi.capsloc.geom.MutableOBB start -> a
    com.gutabi.capsloc.geom.MutableOBB end -> b
    boolean isAABB -> c
    com.gutabi.capsloc.geom.MutableAABB aabb -> d
    double dist -> e
    com.gutabi.capsloc.math.Point dir -> f
    int hash -> g
    void setShape(com.gutabi.capsloc.geom.MutableOBB,com.gutabi.capsloc.geom.MutableOBB) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
com.gutabi.capsloc.geom.OBB -> com.gutabi.a.a.q:
    com.gutabi.capsloc.math.Point center -> a
    double a -> b
    double xExtant -> c
    double yExtant -> d
    com.gutabi.capsloc.math.Point p0 -> e
    com.gutabi.capsloc.math.Point p1 -> f
    com.gutabi.capsloc.math.Point p2 -> g
    com.gutabi.capsloc.math.Point p3 -> h
    com.gutabi.capsloc.math.Point n01 -> n
    com.gutabi.capsloc.math.Point n12 -> o
    double[] n01Projection -> i
    double[] n12Projection -> j
    boolean rightAngle -> k
    com.gutabi.capsloc.geom.AABB aabb -> l
    int hash -> p
    boolean $assertionsDisabled -> m
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    void computeProjections() -> c
    void computeN01() -> d
    void computeN12() -> e
    com.gutabi.capsloc.math.Point getN01() -> a
    com.gutabi.capsloc.math.Point getN12() -> b
    com.gutabi.capsloc.math.Point closestCornerTo(com.gutabi.capsloc.math.Point) -> a
    void project(com.gutabi.capsloc.math.Point,double[]) -> a
    void projectN01(double[]) -> a
    void projectN12(double[]) -> b
com.gutabi.capsloc.geom.ShapeUtils -> com.gutabi.a.a.r:
    boolean $assertionsDisabled -> a
    boolean intersect(java.lang.Object,java.lang.Object) -> a
    boolean intersectArea(java.lang.Object,java.lang.Object) -> b
    boolean touch(java.lang.Object,java.lang.Object) -> c
    boolean contains(java.lang.Object,java.lang.Object) -> d
    boolean intersectAA(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.AABB) -> a
    boolean intersectAA(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.MutableAABB) -> a
    boolean intersectAA(com.gutabi.capsloc.geom.MutableAABB,com.gutabi.capsloc.geom.MutableAABB) -> a
    boolean intersectACap(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.Capsule) -> a
    boolean intersectAC(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.Circle) -> a
    boolean intersectAO(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.OBB) -> a
    boolean intersectAO(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.MutableOBB) -> a
    boolean intersectCapCap(com.gutabi.capsloc.geom.Capsule,com.gutabi.capsloc.geom.Capsule) -> a
    boolean intersectCapC(com.gutabi.capsloc.geom.Capsule,com.gutabi.capsloc.geom.Circle) -> a
    boolean intersectCapO(com.gutabi.capsloc.geom.Capsule,com.gutabi.capsloc.geom.OBB) -> a
    boolean intersectCC(com.gutabi.capsloc.geom.Circle,com.gutabi.capsloc.geom.Circle) -> a
    boolean intersectCO(com.gutabi.capsloc.geom.Circle,com.gutabi.capsloc.geom.OBB) -> a
    boolean intersectCO(com.gutabi.capsloc.geom.Circle,com.gutabi.capsloc.geom.MutableOBB) -> a
    boolean intersectOO(com.gutabi.capsloc.geom.OBB,com.gutabi.capsloc.geom.OBB) -> a
    boolean intersectAreaAA(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.MutableAABB) -> b
    boolean intersectAreaAA(com.gutabi.capsloc.geom.MutableAABB,com.gutabi.capsloc.geom.MutableAABB) -> b
    boolean intersectAreaAL(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.Line) -> a
    boolean intersectAreaAL(com.gutabi.capsloc.geom.MutableAABB,com.gutabi.capsloc.geom.Line) -> a
    boolean intersectAreaAO(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.OBB) -> b
    boolean intersectAreaLO(com.gutabi.capsloc.geom.Line,com.gutabi.capsloc.geom.OBB) -> a
    boolean containsAO(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.OBB) -> c
    boolean containsAO(com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.MutableOBB) -> b
    boolean touchCapC(com.gutabi.capsloc.geom.Capsule,com.gutabi.capsloc.geom.Circle) -> b
    boolean touchCC(com.gutabi.capsloc.geom.Circle,com.gutabi.capsloc.geom.Circle) -> b
com.gutabi.capsloc.geom.SweepEvent -> com.gutabi.a.a.s:
    com.gutabi.capsloc.geom.SweepEventType type -> c
    java.lang.Object stillParent -> d
    java.lang.Object still -> e
    com.gutabi.capsloc.geom.SweeperShape moving -> f
    int index -> g
    double param -> h
    double combo -> i
    com.gutabi.capsloc.math.Point p -> j
    com.gutabi.capsloc.world.graph.Vertex v -> k
    boolean inRoad -> l
    java.util.Comparator COMPARATOR -> m
    java.lang.String toString() -> toString
com.gutabi.capsloc.geom.SweepEvent$SweepEventComparator -> com.gutabi.a.a.t:
    int compare(com.gutabi.capsloc.geom.SweepEvent,com.gutabi.capsloc.geom.SweepEvent) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
com.gutabi.capsloc.geom.SweepEventType -> com.gutabi.a.a.u:
    com.gutabi.capsloc.geom.SweepEventType ENTERROADCAPSULE -> a
    com.gutabi.capsloc.geom.SweepEventType EXITROADCAPSULE -> b
    com.gutabi.capsloc.geom.SweepEventType ENTERROAD -> c
    com.gutabi.capsloc.geom.SweepEventType EXITROAD -> d
    com.gutabi.capsloc.geom.SweepEventType ENTERVERTEX -> e
    com.gutabi.capsloc.geom.SweepEventType EXITVERTEX -> f
    com.gutabi.capsloc.geom.SweepEventType ENTERMERGER -> g
    com.gutabi.capsloc.geom.SweepEventType EXITMERGER -> h
    com.gutabi.capsloc.geom.SweepEventType ENTERSTROKE -> i
    com.gutabi.capsloc.geom.SweepEventType EXITSTROKE -> j
    com.gutabi.capsloc.geom.SweepEventType ENTERBOARD -> k
    com.gutabi.capsloc.geom.SweepEventType EXITBOARD -> l
    com.gutabi.capsloc.geom.SweepEventType ENTERCAR -> m
    com.gutabi.capsloc.geom.SweepEventType EXITCAR -> n
    boolean $assertionsDisabled -> o
    com.gutabi.capsloc.geom.SweepEventType[] ENUM$VALUES -> p
    com.gutabi.capsloc.geom.SweepEventType enter(java.lang.Object) -> a
    com.gutabi.capsloc.geom.SweepEventType exit(java.lang.Object) -> b
    com.gutabi.capsloc.geom.SweepEventType[] values() -> values
    com.gutabi.capsloc.geom.SweepEventType valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.geom.SweepUtils -> com.gutabi.a.a.v:
    boolean $assertionsDisabled -> a
    java.util.List sweepStartCSoverA(java.lang.Object,com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.CapsuleSequence,int) -> a
    java.util.List sweepCSoverA(java.lang.Object,com.gutabi.capsloc.geom.AABB,com.gutabi.capsloc.geom.MutableCapsuleSequence,int,int) -> a
    java.util.List sweepStartCSoverCap(java.lang.Object,com.gutabi.capsloc.geom.Capsule,com.gutabi.capsloc.geom.CapsuleSequence,int) -> a
    java.util.List sweepStartCSoverCap(java.lang.Object,com.gutabi.capsloc.geom.Capsule,com.gutabi.capsloc.geom.MutableCapsuleSequence,int) -> a
    java.util.List sweepCSoverCap(java.lang.Object,com.gutabi.capsloc.geom.Capsule,com.gutabi.capsloc.geom.MutableCapsuleSequence,int,int) -> a
    java.util.List sweepStartCSoverCS(java.lang.Object,com.gutabi.capsloc.geom.CapsuleSequence,com.gutabi.capsloc.geom.CapsuleSequence,int) -> a
    java.util.List sweepStartCSoverCS(java.lang.Object,com.gutabi.capsloc.geom.CapsuleSequence,com.gutabi.capsloc.geom.MutableCapsuleSequence,int) -> a
    java.util.List sweepCSoverCS(java.lang.Object,com.gutabi.capsloc.geom.CapsuleSequence,com.gutabi.capsloc.geom.MutableCapsuleSequence,int,int) -> a
    java.util.List sweepStartCSoverC(java.lang.Object,com.gutabi.capsloc.geom.Circle,com.gutabi.capsloc.geom.CapsuleSequence,int) -> a
    java.util.List sweepCSoverC(java.lang.Object,com.gutabi.capsloc.geom.Circle,com.gutabi.capsloc.geom.MutableCapsuleSequence,int,int) -> a
    double sweepCircleOverLine(com.gutabi.capsloc.geom.Line,com.gutabi.capsloc.geom.Capsule) -> a
    int sweepCircleOverCircle(com.gutabi.capsloc.geom.Circle,com.gutabi.capsloc.geom.Capsule,double[]) -> a
    double firstCollisionParam(com.gutabi.capsloc.geom.Line,com.gutabi.capsloc.geom.SweptOBB) -> a
    double firstCollisionParam(com.gutabi.capsloc.geom.Line,com.gutabi.capsloc.geom.MutableSweptOBB) -> a
    double firstCollisionParam(com.gutabi.capsloc.geom.MutableOBB,com.gutabi.capsloc.geom.SweptOBB) -> a
    double firstCollisionParam(com.gutabi.capsloc.geom.MutableOBB,com.gutabi.capsloc.geom.MutableSweptOBB) -> a
com.gutabi.capsloc.geom.SweeperShape -> com.gutabi.a.a.w:
com.gutabi.capsloc.geom.SweptOBB -> com.gutabi.a.a.x:
    com.gutabi.capsloc.geom.OBB start -> a
    com.gutabi.capsloc.geom.OBB end -> b
    boolean isAABB -> c
    com.gutabi.capsloc.geom.AABB aabb -> d
    double dist -> e
    com.gutabi.capsloc.math.Point dir -> f
    int hash -> g
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
com.gutabi.capsloc.geom.Triangle -> com.gutabi.a.a.y:
    com.gutabi.capsloc.math.Point p0 -> a
    com.gutabi.capsloc.math.Point p1 -> b
    com.gutabi.capsloc.math.Point p2 -> c
com.gutabi.capsloc.math.ColinearException -> com.gutabi.a.b.a:
com.gutabi.capsloc.math.DMath -> com.gutabi.a.b.b:
    java.util.Comparator COMPARATOR -> a
    boolean equals(double,double) -> a
    boolean lessThanEquals(double,double) -> b
    boolean greaterThanEquals(double,double) -> c
    boolean lessThan(double,double) -> d
    boolean greaterThan(double,double) -> e
    boolean rangesOverlap(double[],double[]) -> a
    boolean rangesOverlapArea(double[],double[]) -> b
    boolean rangesOverlapArea(double,double,double,double) -> a
    boolean rangeContains(double[],double[]) -> c
    double sgn(double) -> a
    double quadraticSolve(double,double,double,double[]) -> a
    double lerp(double,double,double) -> a
    double tryAdjustToRightAngle(double) -> b
    double tryAdjustToReducedRightAngle(double) -> c
    boolean isRightAngle(double) -> d
    boolean anglesCompatible(double,double) -> f
com.gutabi.capsloc.math.DMath$DoubleComparator -> com.gutabi.a.b.c:
    int compare(java.lang.Double,java.lang.Double) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
com.gutabi.capsloc.math.Dim -> com.gutabi.a.b.d:
    double width -> a
    double height -> b
    int hash -> c
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
com.gutabi.capsloc.math.OverlappingException -> com.gutabi.a.b.e:
    com.gutabi.capsloc.math.Point a -> a
    com.gutabi.capsloc.math.Point b -> b
    com.gutabi.capsloc.math.Point c -> c
    com.gutabi.capsloc.math.Point d -> d
com.gutabi.capsloc.math.Point -> com.gutabi.a.b.f:
    com.gutabi.capsloc.math.Point UP -> a
    com.gutabi.capsloc.math.Point DOWN -> b
    com.gutabi.capsloc.math.Point LEFT -> c
    com.gutabi.capsloc.math.Point RIGHT -> d
    double x -> e
    double y -> f
    int hash -> h
    boolean $assertionsDisabled -> g
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    double distanceTo(com.gutabi.capsloc.math.Point) -> a
    com.gutabi.capsloc.math.Point intersection(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> a
    com.gutabi.capsloc.math.Point point(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,double) -> a
    double travelForward(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,double,double) -> a
    double travelBackward(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,double,double) -> b
    boolean intersect(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> a
    boolean colinear(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> b
    double u(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> c
    double uNoProjection(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> d
    double distance(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> e
    double param(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> f
    double param(double,double,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> a
    double distance(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> a
    double distance(double,double,double,double) -> a
    int circleLineIntersections(com.gutabi.capsloc.math.Point,double,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point[]) -> a
    int circleSegmentIntersections(com.gutabi.capsloc.math.Point,double,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point[]) -> b
    double dot(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> b
    com.gutabi.capsloc.math.Point cw90AndNormalize(com.gutabi.capsloc.math.Point) -> b
    com.gutabi.capsloc.math.Point ccw90AndNormalize(com.gutabi.capsloc.math.Point) -> c
    com.gutabi.capsloc.math.Point normalize() -> a
    com.gutabi.capsloc.math.Point normalize(double,double) -> a
    boolean isRightAngleNormal() -> b
    double length() -> c
    com.gutabi.capsloc.math.Point multiply(double) -> a
    com.gutabi.capsloc.math.Point plus(com.gutabi.capsloc.math.Point) -> d
    com.gutabi.capsloc.math.Point minus(com.gutabi.capsloc.math.Point) -> e
    com.gutabi.capsloc.math.Point minus(double,double) -> b
    com.gutabi.capsloc.math.Point minusAndNormalize(com.gutabi.capsloc.math.Point) -> f
    com.gutabi.capsloc.math.Point negate() -> d
    double lengthSquared() -> e
    com.gutabi.capsloc.math.Point panelToWorld(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.world.WorldCamera) -> a
    com.gutabi.capsloc.math.Point worldToPanel(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.world.WorldCamera) -> b
    com.gutabi.capsloc.math.Point worldToPanel(double,double,com.gutabi.capsloc.world.WorldCamera) -> a
    void worldToPanel(com.gutabi.capsloc.geom.MutableAABB,com.gutabi.capsloc.world.WorldCamera,com.gutabi.capsloc.geom.MutableAABB) -> a
    com.gutabi.capsloc.math.Point panelToMenu(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.ui.Menu) -> a
    com.gutabi.capsloc.math.Point contentPaneToPanel(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.ui.Panel) -> a
com.gutabi.capsloc.ui.ContentPane -> com.gutabi.a.c.a:
    com.gutabi.capsloc.ui.PlatformContentPane pcp -> a
    void postDisplay(int,int) -> a
    void repaint() -> a
com.gutabi.capsloc.ui.Image -> com.gutabi.a.c.b:
    int getWidth() -> a
    int getHeight() -> b
com.gutabi.capsloc.ui.InputEvent -> com.gutabi.a.c.c:
    com.gutabi.capsloc.math.Point p -> a
    com.gutabi.capsloc.ui.Panel panel -> b
com.gutabi.capsloc.ui.Label -> com.gutabi.a.c.d:
    java.lang.String text -> a
    com.gutabi.capsloc.Resource fontFile -> b
    com.gutabi.capsloc.ui.paint.FontStyle fontStyle -> c
    int fontSize -> d
    com.gutabi.capsloc.ui.paint.Color color -> e
    com.gutabi.capsloc.geom.AABB localAABB -> f
    com.gutabi.capsloc.geom.AABB aabb -> g
    void renderLocal() -> a
    void render() -> b
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.ui.Menu -> com.gutabi.a.c.e:
    boolean rendered -> f
    java.util.concurrent.locks.Lock lock -> g
    java.util.List tree -> h
    java.util.List colAABBs -> i
    com.gutabi.capsloc.ui.MenuItem hilited -> j
    com.gutabi.capsloc.ui.MenuItem firstMenuItem -> k
    com.gutabi.capsloc.ui.MenuItem shimmeringMenuItem -> l
    int rows -> m
    int cols -> n
    double[] columnWidth -> o
    double[] columnHeight -> p
    com.gutabi.capsloc.geom.AABB aabb -> q
    com.gutabi.capsloc.geom.AABB marginAABB -> r
    int parWidth -> s
    int parHeight -> t
    double widthFraction -> u
    double scale -> v
    double menuWidth -> w
    double menuHeight -> x
    boolean hScrollable -> y
    boolean vScrollable -> z
    com.gutabi.capsloc.ui.Shimmer shimmer -> A
    void setLocation(double,double) -> a
    void setLocation(com.gutabi.capsloc.math.Point) -> a
    void add(com.gutabi.capsloc.ui.MenuItem,int,int) -> a
    void pressed(com.gutabi.capsloc.ui.InputEvent) -> a
    void released(com.gutabi.capsloc.ui.InputEvent) -> b
    void dragToNewLocation(com.gutabi.capsloc.math.Point) -> b
    com.gutabi.capsloc.ui.MenuItem hitTest(com.gutabi.capsloc.math.Point) -> c
    void postDisplay(int,int) -> a
    void render() -> h
    void setAABBAndScrolling() -> a
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.ui.MenuItem -> com.gutabi.a.c.f:
    com.gutabi.capsloc.ui.Menu menu -> b
    com.gutabi.capsloc.ui.Label lab -> c
    com.gutabi.capsloc.ui.Label auxLab0 -> d
    com.gutabi.capsloc.ui.Label auxLab1 -> e
    com.gutabi.capsloc.ui.Label auxLab2 -> f
    boolean border -> g
    com.gutabi.capsloc.geom.AABB localAABB -> h
    com.gutabi.capsloc.geom.AABB aabb -> i
    boolean active -> j
    int r -> k
    int c -> l
    com.gutabi.capsloc.ui.MenuItem minimumWidth -> m
    boolean hitTest(com.gutabi.capsloc.math.Point) -> a
    void action() -> a
    void render() -> b
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintHilited(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
com.gutabi.capsloc.ui.MenuItem$1 -> com.gutabi.a.c.g:
    void action() -> a
com.gutabi.capsloc.ui.MenuTool -> com.gutabi.a.c.h:
    com.gutabi.capsloc.math.Point origMenuUL -> a
    com.gutabi.capsloc.math.Point origPressed -> b
    void pressed(com.gutabi.capsloc.ui.InputEvent) -> a
    void dragged(com.gutabi.capsloc.ui.InputEvent) -> c
    void released(com.gutabi.capsloc.ui.InputEvent) -> b
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.ui.Paintable -> com.gutabi.a.c.i:
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.ui.Panel -> com.gutabi.a.c.j:
    com.gutabi.capsloc.geom.AABB aabb -> a
    com.gutabi.capsloc.math.Point lastMovedOrDraggedPanelPoint -> b
    com.gutabi.capsloc.math.Point lastPressedPanelPoint -> c
    com.gutabi.capsloc.math.Point lastDraggedPanelPoint -> d
    void pressed(com.gutabi.capsloc.ui.InputEvent) -> a
    void released(com.gutabi.capsloc.ui.InputEvent) -> b
    void dragged(com.gutabi.capsloc.ui.InputEvent) -> c
    void postDisplay(int,int) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.ui.PlatformContentPane -> com.gutabi.a.c.k:
    java.util.List children -> b
    com.gutabi.capsloc.math.Point lastPressedContentPanePoint -> a
    com.gutabi.capsloc.math.Point lastDraggedContentPanePoint -> c
    java.util.List getChildren() -> b
    void pressedDriver(com.gutabi.capsloc.math.Point) -> a
    void releasedDriver(com.gutabi.capsloc.math.Point) -> b
    void draggedDriver(com.gutabi.capsloc.math.Point) -> c
    void postDisplay(int,int) -> a
    void repaint() -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.ui.Shimmer -> com.gutabi.a.c.l:
    double x -> a
    double y -> b
    double width -> c
    double height -> d
    double brX -> e
    double brY -> f
    double startMillis -> g
    com.gutabi.capsloc.geom.MutablePolygon poly -> h
    com.gutabi.capsloc.geom.GeometryPath path -> i
    double traverseSpeed -> j
    double timeToRest -> k
    double timeToTraverse -> l
    double t -> m
    boolean alreadyRested -> n
    boolean $assertionsDisabled -> o
    void setShape(com.gutabi.capsloc.geom.AABB) -> a
    void setShape(com.gutabi.capsloc.geom.MutableAABB) -> a
    boolean step() -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.ui.paint.Cap -> com.gutabi.a.c.a.a:
    com.gutabi.capsloc.ui.paint.Cap BUTT -> a
    com.gutabi.capsloc.ui.paint.Cap ROUND -> b
    com.gutabi.capsloc.ui.paint.Cap SQUARE -> c
    com.gutabi.capsloc.ui.paint.Cap[] ENUM$VALUES -> d
    com.gutabi.capsloc.ui.paint.Cap[] values() -> values
    com.gutabi.capsloc.ui.paint.Cap valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.ui.paint.Color -> com.gutabi.a.c.a.b:
    com.gutabi.capsloc.ui.paint.Color ROADCOLOR -> a
    com.gutabi.capsloc.ui.paint.Color FIXTURECOLOR -> b
    com.gutabi.capsloc.ui.paint.Color RED -> c
    com.gutabi.capsloc.ui.paint.Color ORANGE -> d
    com.gutabi.capsloc.ui.paint.Color YELLOW -> e
    com.gutabi.capsloc.ui.paint.Color GREEN -> f
    com.gutabi.capsloc.ui.paint.Color LIGHTGREEN -> g
    com.gutabi.capsloc.ui.paint.Color DARKGREEN -> h
    com.gutabi.capsloc.ui.paint.Color BLUE -> i
    com.gutabi.capsloc.ui.paint.Color WHITE -> j
    com.gutabi.capsloc.ui.paint.Color GRAY -> k
    com.gutabi.capsloc.ui.paint.Color LIGHT_GRAY -> l
    com.gutabi.capsloc.ui.paint.Color DARK_GRAY -> m
    com.gutabi.capsloc.ui.paint.Color BLACK -> n
    com.gutabi.capsloc.ui.paint.Color menuBackground -> o
    com.gutabi.capsloc.ui.paint.Color brown -> p
    com.gutabi.capsloc.ui.paint.Color redOrange -> q
    com.gutabi.capsloc.ui.paint.Color fixtureHiliteColor -> r
    com.gutabi.capsloc.ui.paint.Color roadHiliteColor -> s
    int r -> t
    int g -> u
    int b -> v
    int a -> w
com.gutabi.capsloc.ui.paint.FontStyle -> com.gutabi.a.c.a.c:
    com.gutabi.capsloc.ui.paint.FontStyle PLAIN -> a
    com.gutabi.capsloc.ui.paint.FontStyle[] ENUM$VALUES -> b
    com.gutabi.capsloc.ui.paint.FontStyle[] values() -> values
    com.gutabi.capsloc.ui.paint.FontStyle valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.ui.paint.Join -> com.gutabi.a.c.a.d:
    com.gutabi.capsloc.ui.paint.Join BEVEL -> a
    com.gutabi.capsloc.ui.paint.Join MITER -> b
    com.gutabi.capsloc.ui.paint.Join ROUND -> c
    com.gutabi.capsloc.ui.paint.Join[] ENUM$VALUES -> d
    com.gutabi.capsloc.ui.paint.Join[] values() -> values
    com.gutabi.capsloc.ui.paint.Join valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.ui.paint.RenderingContext -> com.gutabi.a.c.a.e:
    com.gutabi.capsloc.world.WorldCamera cam -> g
    void setAlpha(double) -> c
    void setStroke(double,com.gutabi.capsloc.ui.paint.Cap,com.gutabi.capsloc.ui.paint.Join) -> a
    void setColor(com.gutabi.capsloc.ui.paint.Color) -> b
    void setXORMode(com.gutabi.capsloc.ui.paint.Color) -> a
    void clearXORMode() -> b
    void setFont(com.gutabi.capsloc.Resource,com.gutabi.capsloc.ui.paint.FontStyle,int) -> a
    void scale(double) -> b
    void translate(double,double) -> a
    void clip(com.gutabi.capsloc.geom.AABB) -> c
    void pushTransform() -> c
    void popTransform() -> d
    void pushClip() -> e
    void popClip() -> f
    void rotate(double) -> a
    void paintString(double,double,double,java.lang.String) -> a
    void paintImage(com.gutabi.capsloc.ui.Image,double,double,double,double,double,int,int,int,int) -> a
    void paintImage(com.gutabi.capsloc.ui.Image,int,int,int,int,int,int,int,int) -> a
    void dispose() -> a
    void drawAABB(com.gutabi.capsloc.geom.AABB) -> a
    void paintAABB(com.gutabi.capsloc.geom.AABB) -> b
    void drawAABB(com.gutabi.capsloc.geom.MutableAABB) -> a
    void drawLine(com.gutabi.capsloc.geom.Line) -> a
    void paintCircle(com.gutabi.capsloc.geom.Circle) -> a
com.gutabi.capsloc.world.CarMap -> com.gutabi.a.d.a:
    com.gutabi.capsloc.world.World world -> a
    java.util.List cars -> b
    java.util.List toBeRemoved -> c
    boolean $assertionsDisabled -> d
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum -> e
    void addCar(com.gutabi.capsloc.world.cars.Car) -> a
    int size() -> a
    com.gutabi.capsloc.world.cars.Car findRedCar() -> b
    com.gutabi.capsloc.world.cars.Car carHitTest(com.gutabi.capsloc.math.Point) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    boolean preStep(double) -> a
    void postStep(double) -> b
    void findDeadlockCycles(double) -> c
    com.gutabi.capsloc.world.cars.DrivingEvent findDeadlockEvent(com.gutabi.capsloc.world.cars.AutonomousDriver) -> a
    com.gutabi.capsloc.world.cars.AutonomousDriver findDeadlockCause(com.gutabi.capsloc.world.cars.AutonomousDriver) -> b
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum() -> c
com.gutabi.capsloc.world.GrassMap -> com.gutabi.a.d.b:
    java.util.List grass -> a
    java.util.List toRemove -> b
    void addGrass(com.gutabi.capsloc.world.sprites.AnimatedGrass) -> a
    void mowGrass(java.lang.Object) -> a
    void preStart() -> a
    boolean step(double) -> a
    void paintScene(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.world.Quadrant -> com.gutabi.a.d.c:
    com.gutabi.capsloc.world.QuadrantMap map -> a
    int r -> b
    int c -> c
    boolean active -> d
    com.gutabi.capsloc.world.Quadrant up -> e
    com.gutabi.capsloc.world.Quadrant left -> f
    com.gutabi.capsloc.world.Quadrant right -> g
    com.gutabi.capsloc.world.Quadrant down -> h
    com.gutabi.capsloc.world.Quadrant rightDown -> i
    boolean grid -> j
    com.gutabi.capsloc.geom.AABB aabb -> k
    double gridSpacing -> l
    void init() -> a
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.world.QuadrantMap -> com.gutabi.a.d.d:
    com.gutabi.capsloc.geom.AABB worldAABB -> a
    int quadrantCols -> b
    int quadrantRows -> c
    int[][] ini -> d
    com.gutabi.capsloc.world.Quadrant[][] quadrants -> i
    com.gutabi.capsloc.ui.Image quadrantGrass -> e
    com.gutabi.capsloc.world.GrassMap grassMap -> f
    com.gutabi.capsloc.ui.paint.RenderingContext ctxt -> g
    boolean $assertionsDisabled -> h
    com.gutabi.capsloc.world.Quadrant[][] initQuadrants(int[][]) -> a
    void panelPostDisplay(com.gutabi.capsloc.world.WorldCamera) -> a
    boolean contains(java.lang.Object) -> a
    void preStart() -> a
    boolean step(double) -> a
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintScene(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
com.gutabi.capsloc.world.Stats -> com.gutabi.a.d.e:
    com.gutabi.capsloc.world.World world -> a
    long lastTime -> b
    long curTime -> c
    int frameCount -> d
    int fps -> e
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.world.Stroke -> com.gutabi.a.d.f:
    double STROKE_RADIUS -> a
    com.gutabi.capsloc.world.World world -> b
    java.util.List cs -> f
    boolean finished -> g
    java.util.List caps -> c
    com.gutabi.capsloc.geom.CapsuleSequence seq -> d
    com.gutabi.capsloc.geom.AABB aabb -> h
    boolean $assertionsDisabled -> e
    int[] $SWITCH_TABLE$com$gutabi$capsloc$geom$SweepEventType -> i
    void add(com.gutabi.capsloc.math.Point) -> a
    com.gutabi.capsloc.math.Point get(int) -> a
    com.gutabi.capsloc.geom.Circle getCircle(int) -> b
    int size() -> a
    void finish() -> b
    java.util.Set processNewStroke(boolean) -> a
    java.util.List events(boolean) -> b
    java.util.List selfEvents(com.gutabi.capsloc.geom.MutableCapsuleSequence,int,java.util.List) -> a
    void computeAABB() -> d
    int[] $SWITCH_TABLE$com$gutabi$capsloc$geom$SweepEventType() -> c
com.gutabi.capsloc.world.World -> com.gutabi.a.d.g:
    com.gutabi.capsloc.world.WorldCamera worldCamera -> i
    java.util.concurrent.atomic.AtomicBoolean simThreadTrigger -> j
    java.lang.Thread simThread -> k
    com.gutabi.capsloc.world.WorldBackground background -> l
    com.gutabi.capsloc.world.QuadrantMap quadrantMap -> m
    com.gutabi.capsloc.world.graph.Graph graph -> n
    com.gutabi.capsloc.world.CarMap carMap -> o
    com.gutabi.capsloc.world.Stats stats -> p
    com.gutabi.capsloc.ui.Shimmer shimmer -> q
    com.gutabi.capsloc.math.Point lastPressedWorldPoint -> r
    com.gutabi.capsloc.math.Point lastDraggedWorldPoint -> s
    com.gutabi.capsloc.math.Point lastReleasedWorldPoint -> t
    com.gutabi.capsloc.math.Point penDraggedWorldPoint -> u
    boolean lastDraggedWorldPointWasNull -> v
    com.gutabi.capsloc.math.Point lastMovedOrDraggedWorldPoint -> w
    com.gutabi.capsloc.ui.paint.RenderingContext ctxt -> x
    com.gutabi.capsloc.geom.MutableAABB shimmerTmp -> y
    boolean $assertionsDisabled -> z
    void panelPostDisplay(int,int) -> b
    void preStart() -> k
    boolean integrate(double) -> a
    boolean preStep() -> a
    boolean step() -> l
    void postStep() -> b
    java.util.Set addFixture(com.gutabi.capsloc.world.graph.Fixture) -> a
    java.util.Set addIntersection(com.gutabi.capsloc.world.graph.Intersection) -> a
    com.gutabi.capsloc.world.graph.Intersection splitRoad(com.gutabi.capsloc.world.graph.RoadPosition) -> a
    java.util.Set createRoad(com.gutabi.capsloc.world.graph.Vertex,com.gutabi.capsloc.world.graph.Vertex,java.util.List) -> a
    com.gutabi.capsloc.world.graph.BypassBoard createBypassBoard(com.gutabi.capsloc.math.Point,char[][]) -> a
    void pressed(com.gutabi.capsloc.ui.InputEvent) -> a
    void released(com.gutabi.capsloc.ui.InputEvent) -> b
    void dragged(com.gutabi.capsloc.ui.InputEvent) -> c
    void render_worldPanel() -> h
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintStats(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
com.gutabi.capsloc.world.WorldBackground -> com.gutabi.a.d.h:
    com.gutabi.capsloc.world.WorldBackground$RenderMethod method -> a
    com.gutabi.capsloc.world.World world -> b
    com.gutabi.capsloc.ui.Image img -> e
    int panelWidth -> c
    int panelHeight -> d
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod -> f
    void panelPostDisplay(int,int) -> a
    void render() -> a
    void paint_pixels(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paint_worldCoords(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod() -> b
com.gutabi.capsloc.world.WorldBackground$RenderMethod -> com.gutabi.a.d.i:
    com.gutabi.capsloc.world.WorldBackground$RenderMethod MONOLITHIC -> a
    com.gutabi.capsloc.world.WorldBackground$RenderMethod DYNAMIC -> b
    com.gutabi.capsloc.world.WorldBackground$RenderMethod RENDERED_GRAPH -> c
    com.gutabi.capsloc.world.WorldBackground$RenderMethod RENDERED_ROADS -> d
    com.gutabi.capsloc.world.WorldBackground$RenderMethod RENDERED_ROADS_VERTICES -> e
    com.gutabi.capsloc.world.WorldBackground$RenderMethod RENDERED_ROADS_VERTICES_BOARDS -> f
    com.gutabi.capsloc.world.WorldBackground$RenderMethod[] ENUM$VALUES -> g
    com.gutabi.capsloc.world.WorldBackground$RenderMethod[] values() -> values
    com.gutabi.capsloc.world.WorldBackground$RenderMethod valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.WorldCamera -> com.gutabi.a.d.j:
    double pixelsPerMeter -> a
    double origPixelsPerMeter -> b
    com.gutabi.capsloc.geom.MutableAABB worldViewport -> c
    com.gutabi.capsloc.geom.AABB origWorldViewport -> d
    com.gutabi.capsloc.geom.AABB previewAABB -> e
    com.gutabi.capsloc.geom.AABB panelAABB -> f
    void panAbsolute(double,double) -> a
com.gutabi.capsloc.world.WorldPanel -> com.gutabi.a.d.k:
    void postDisplay(int,int) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.world.cars.AutonomousCar -> com.gutabi.a.d.a.a:
    com.gutabi.capsloc.world.graph.Fixture source -> a
    boolean $assertionsDisabled -> b
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum -> c
    com.gutabi.capsloc.world.cars.AutonomousCar createCar(com.gutabi.capsloc.world.World,com.gutabi.capsloc.world.sprites.CarSheet$CarType,com.gutabi.capsloc.world.graph.Fixture,int) -> a
    void computeStartingProperties() -> a
    boolean preStep(double) -> a
    boolean postStep(double) -> c
    void computeDynamicPropertiesMovingAndMore(double) -> b
    void skid() -> b
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum() -> e
com.gutabi.capsloc.world.cars.AutonomousDriver -> com.gutabi.a.d.a.b:
    double carProximityLookahead -> a
    double vertexArrivalLookahead -> b
    com.gutabi.capsloc.world.cars.VertexArrivalEvent curVertexArrivalEvent -> c
    com.gutabi.capsloc.world.cars.CarProximityEvent curCarProximityEvent -> d
    java.util.List vertexDepartureQueue -> e
    double decelTime -> f
    double stoppedTime -> g
    boolean deadlocked -> h
    boolean $assertionsDisabled -> i
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum -> v
    void computeStartingProperties() -> a
    void cleanupVertexDepartureQueue() -> d
    void clear() -> b
    void preStep(double) -> a
    void postStep(double) -> b
    com.gutabi.capsloc.world.cars.CarProximityEvent findNewCarProximityEvent() -> e
    com.gutabi.capsloc.world.cars.VertexArrivalEvent findNewVertexArrivalEvent() -> f
    boolean handleDrivingEvent(com.gutabi.capsloc.world.cars.DrivingEvent,double) -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum() -> c
com.gutabi.capsloc.world.cars.AutonomousEngine -> com.gutabi.a.d.a.c:
    boolean $assertionsDisabled -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum -> o
    void preStep(double) -> a
    void updateFriction() -> b
    void updateDrive() -> c
    void turn() -> d
    void updateBrake(double) -> b
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum() -> a
com.gutabi.capsloc.world.cars.Car -> com.gutabi.a.d.a.d:
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type -> e
    com.gutabi.capsloc.world.cars.CarStateEnum state -> f
    double startingTime -> g
    com.gutabi.capsloc.world.cars.Driver driver -> h
    com.gutabi.capsloc.world.cars.Engine engine -> i
    int id -> j
    boolean atleastPartiallyOnRoad -> k
    boolean inMerger -> l
    com.gutabi.capsloc.math.Point toolOrigCenter -> m
    com.gutabi.capsloc.geom.MutableOBB toolOrigShape -> n
    boolean destroyed -> o
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite sprite -> p
    int sheetIndex -> q
    com.gutabi.capsloc.geom.GeometryPath path -> r
    int carIDCounter -> s
    double BRAKE_SIZE -> t
    double BRAKE_LOCALX -> u
    double BRAKE_LOCALY -> v
    double CAR_BRAKE1X -> w
    double CAR_BRAKE1Y -> x
    double CAR_BRAKE2X -> y
    double CAR_BRAKE2Y -> z
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum -> a
    void computeCtorProperties(int) -> a
    void setTransform(com.gutabi.capsloc.math.Point,double) -> a
    void destroy() -> f
    com.gutabi.capsloc.Entity hitTest(com.gutabi.capsloc.math.Point) -> a
    boolean isUserDeleteable() -> c
    void preStart() -> d
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintImage(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
    void paintRect(com.gutabi.capsloc.ui.paint.RenderingContext) -> c
    void paintBrakes(com.gutabi.capsloc.ui.paint.RenderingContext) -> d
    void paintID(com.gutabi.capsloc.ui.paint.RenderingContext) -> e
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$cars$CarStateEnum() -> g
com.gutabi.capsloc.world.cars.CarProximityEvent -> com.gutabi.a.d.a.e:
    com.gutabi.capsloc.world.cars.AutonomousDriver d -> a
    com.gutabi.capsloc.world.cars.AutonomousDriver otherDriver -> b
    int hash -> c
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
com.gutabi.capsloc.world.cars.CarStateEnum -> com.gutabi.a.d.a.f:
    com.gutabi.capsloc.world.cars.CarStateEnum DRIVING -> a
    com.gutabi.capsloc.world.cars.CarStateEnum BRAKING -> b
    com.gutabi.capsloc.world.cars.CarStateEnum CRASHED -> c
    com.gutabi.capsloc.world.cars.CarStateEnum SKIDDED -> d
    com.gutabi.capsloc.world.cars.CarStateEnum SINKED -> e
    com.gutabi.capsloc.world.cars.CarStateEnum IDLE -> f
    com.gutabi.capsloc.world.cars.CarStateEnum DRAGGING -> g
    com.gutabi.capsloc.world.cars.CarStateEnum COASTING_FORWARD -> h
    com.gutabi.capsloc.world.cars.CarStateEnum COASTING_BACKWARD -> i
    com.gutabi.capsloc.world.cars.CarStateEnum[] ENUM$VALUES -> j
    com.gutabi.capsloc.world.cars.CarStateEnum[] values() -> values
    com.gutabi.capsloc.world.cars.CarStateEnum valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.cars.Driver -> com.gutabi.a.d.a.g:
    com.gutabi.capsloc.world.cars.Car c -> j
    com.gutabi.capsloc.world.graph.GraphPosition startGP -> k
    com.gutabi.capsloc.world.graph.Side startSide -> l
    com.gutabi.capsloc.world.graph.GraphPositionPath overallPath -> m
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition overallPos -> n
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition prevOverallPos -> o
    com.gutabi.capsloc.math.Point goalPoint -> p
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition toolOrigOverallPos -> q
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition toolOrigExitingVertexPos -> r
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition toolLastExitingVertexPos -> s
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition toolCoastingGoal -> t
    boolean $assertionsDisabled -> u
    void setOverallPos(com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> a
com.gutabi.capsloc.world.cars.DrivingEvent -> com.gutabi.a.d.a.h:
com.gutabi.capsloc.world.cars.Engine -> com.gutabi.a.d.a.i:
    double maxSpeed -> b
    double maxRadsPerMeter -> c
    double maxAcceleration -> d
    double frictionForwardImpulseCoefficient -> e
    double frictionLateralImpulseCoefficient -> f
    double frictionAngularImpulseCoefficient -> g
    double driveForwardImpulseCoefficient -> h
    double driveLateralImpulseCoefficient -> i
    double brakeForwardImpulseCoefficient -> j
    double brakeLateralImpulseCoefficient -> k
    double turnAngularImpulseCoefficient -> l
    com.gutabi.capsloc.world.World world -> m
    com.gutabi.capsloc.world.cars.Car c -> n
    void preStep(double) -> a
com.gutabi.capsloc.world.cars.VertexArrivalEvent -> com.gutabi.a.d.a.j:
    com.gutabi.capsloc.world.cars.Driver d -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition entrancePosition -> b
    com.gutabi.capsloc.world.graph.StopSign sign -> c
    int hash -> g
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
com.gutabi.capsloc.world.cars.VertexEvent -> com.gutabi.a.d.a.k:
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition vertexPosition -> d
    com.gutabi.capsloc.world.graph.Vertex v -> e
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition carPastExitPosition -> f
com.gutabi.capsloc.world.cars.VertexSpawnEvent -> com.gutabi.a.d.a.l:
com.gutabi.capsloc.world.graph.Axis -> com.gutabi.a.d.b.a:
    com.gutabi.capsloc.world.graph.Axis TOPBOTTOM -> a
    com.gutabi.capsloc.world.graph.Axis LEFTRIGHT -> b
    boolean $assertionsDisabled -> c
    com.gutabi.capsloc.world.graph.Axis[] ENUM$VALUES -> d
    com.gutabi.capsloc.world.graph.Axis[] values() -> values
    com.gutabi.capsloc.world.graph.Axis valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.graph.BorderStud -> com.gutabi.a.d.b.b:
    com.gutabi.capsloc.world.graph.Fixture f -> a
    boolean $assertionsDisabled -> b
    boolean across(com.gutabi.capsloc.world.graph.BorderStud) -> a
    boolean withinRowRange(int) -> a
    boolean withinColRange(int) -> b
com.gutabi.capsloc.world.graph.BypassBoard -> com.gutabi.a.d.b.c:
    com.gutabi.capsloc.ui.paint.Color BOARDCOLOR -> a
    com.gutabi.capsloc.world.World world -> b
    com.gutabi.capsloc.math.Point center -> c
    char[][] ini -> d
    java.util.List studs -> e
    java.util.List perimeterSegments -> f
    java.util.List neg -> g
    int originRow -> h
    int originCol -> i
    int rowCount -> j
    int colCount -> k
    com.gutabi.capsloc.math.Point ul -> l
    com.gutabi.capsloc.geom.AABB allStudsAABB -> m
    com.gutabi.capsloc.geom.AABB gridAABB -> n
    com.gutabi.capsloc.geom.AABB gridFudgeAABB -> o
    com.gutabi.capsloc.geom.AABB zoomingAABB -> p
    int jStudCount -> q
    com.gutabi.capsloc.world.graph.BorderStud[] jStuds -> r
    int kStudCount -> s
    com.gutabi.capsloc.world.graph.BorderStud[] kStuds -> t
    com.gutabi.capsloc.world.graph.BorderStud yStud -> u
    com.gutabi.capsloc.world.graph.Vertex exitVertex -> v
    java.util.Map rowTracks -> w
    java.util.Map colTracks -> x
    java.util.Map rowPaths -> D
    java.util.Map colPaths -> E
    com.gutabi.capsloc.ui.Image img -> y
    com.gutabi.capsloc.geom.MutableAABB test -> z
    com.gutabi.capsloc.geom.MutableAABB testFloor -> A
    com.gutabi.capsloc.geom.MutableAABB testCeil -> B
    boolean $assertionsDisabled -> C
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Side -> F
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Axis -> G
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod -> H
    void addExitRoad(com.gutabi.capsloc.world.graph.BorderStud) -> a
    void addExitRoadToTrack(java.util.List,com.gutabi.capsloc.world.graph.BorderStud) -> a
    void addJointRoad(com.gutabi.capsloc.world.graph.BorderStud[]) -> a
    void exitTrackToPath(com.gutabi.capsloc.world.graph.BorderStud) -> b
    void jointTracksToPath(com.gutabi.capsloc.world.graph.BorderStud,com.gutabi.capsloc.world.graph.BorderStud) -> a
    void jointTracksToPath(com.gutabi.capsloc.world.graph.BorderStud,com.gutabi.capsloc.world.graph.BorderStud,com.gutabi.capsloc.world.graph.BorderStud,com.gutabi.capsloc.world.graph.BorderStud) -> a
    void removePerimeterSegment(com.gutabi.capsloc.geom.Line) -> a
    void preStart() -> d
    boolean preStep(double) -> a
    boolean postStep(double) -> c
    com.gutabi.capsloc.world.graph.GraphPositionPath getPath(com.gutabi.capsloc.world.graph.Axis,int) -> a
    com.gutabi.capsloc.math.Point point(double,double) -> a
    com.gutabi.capsloc.world.graph.BypassBoardPosition position(com.gutabi.capsloc.math.Point) -> a
    boolean withinGrid(com.gutabi.capsloc.world.cars.Car,double,com.gutabi.capsloc.math.Point) -> a
    boolean floorAndCeilWithinGrid(com.gutabi.capsloc.world.cars.Car) -> a
    boolean enteringBoard(com.gutabi.capsloc.world.graph.BypassBoardPosition,com.gutabi.capsloc.world.graph.BypassBoardPosition) -> a
    double carInGridFraction(com.gutabi.capsloc.world.cars.Car) -> b
    boolean isUserDeleteable() -> c
    void render() -> a
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintStuds(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Side() -> b
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Axis() -> e
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod() -> f
com.gutabi.capsloc.world.graph.BypassBoardPosition -> com.gutabi.a.d.b.d:
    double rowCombo -> a
    double colCombo -> b
    int rowIndex -> c
    int colIndex -> d
    double rowParam -> e
    double colParam -> f
    boolean bound -> g
    int hash -> k
    boolean $assertionsDisabled -> h
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isBound() -> a
    com.gutabi.capsloc.world.graph.GraphPosition approachNeighbor(com.gutabi.capsloc.world.graph.GraphPosition,double) -> a
    double goalGPPPCombo(int,double,boolean,com.gutabi.capsloc.world.graph.GraphPosition,com.gutabi.capsloc.world.graph.GraphPositionPath,com.gutabi.capsloc.world.graph.GraphPositionPathPosition,double) -> a
com.gutabi.capsloc.world.graph.BypassStud -> com.gutabi.a.d.b.e:
    com.gutabi.capsloc.world.World world -> c
    com.gutabi.capsloc.world.graph.BypassBoard board -> d
    int row -> e
    int col -> f
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite sprite -> g
    com.gutabi.capsloc.geom.AABB aabb -> h
    java.lang.String toString() -> toString
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.world.graph.Direction -> com.gutabi.a.d.b.f:
    com.gutabi.capsloc.world.graph.Direction STARTTOEND -> a
    com.gutabi.capsloc.world.graph.Direction ENDTOSTART -> b
    boolean $assertionsDisabled -> c
    com.gutabi.capsloc.world.graph.Direction[] ENUM$VALUES -> d
    com.gutabi.capsloc.world.graph.Direction[] values() -> values
    com.gutabi.capsloc.world.graph.Direction valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.graph.Edge -> com.gutabi.a.d.b.g:
    int id -> a
    int pointCount() -> a
    double getTotalLength(com.gutabi.capsloc.world.graph.Vertex,com.gutabi.capsloc.world.graph.Vertex) -> a
    com.gutabi.capsloc.world.graph.Direction getDirection(com.gutabi.capsloc.world.graph.Axis) -> a
    com.gutabi.capsloc.world.graph.Vertex getReferenceVertex(com.gutabi.capsloc.world.graph.Axis) -> b
    com.gutabi.capsloc.world.graph.Vertex getOtherVertex(com.gutabi.capsloc.world.graph.Axis) -> c
    com.gutabi.capsloc.world.graph.GraphPosition travelFromReferenceVertex(com.gutabi.capsloc.world.graph.Axis,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelFromOtherVertex(com.gutabi.capsloc.world.graph.Axis,double) -> b
com.gutabi.capsloc.world.graph.EdgePosition -> com.gutabi.a.d.b.h:
    com.gutabi.capsloc.world.graph.Axis axis -> a
    boolean $assertionsDisabled -> b
    com.gutabi.capsloc.world.graph.GraphPosition travelToReferenceVertex(com.gutabi.capsloc.world.graph.Axis,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelToOtherVertex(com.gutabi.capsloc.world.graph.Axis,double) -> b
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundTowardReferenceVertex() -> b
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundTowardOtherVertex() -> c
    int getIndex() -> d
    double getParam() -> e
    double getCombo() -> f
    com.gutabi.capsloc.world.graph.GraphPosition approachNeighbor(com.gutabi.capsloc.world.graph.GraphPosition,double) -> a
    double goalGPPPCombo(int,double,boolean,com.gutabi.capsloc.world.graph.GraphPosition,com.gutabi.capsloc.world.graph.GraphPositionPath,com.gutabi.capsloc.world.graph.GraphPositionPathPosition,double) -> a
com.gutabi.capsloc.world.graph.Fixture -> com.gutabi.a.d.b.i:
    double SPAWN_FREQUENCY_SECONDS -> a
    com.gutabi.capsloc.world.graph.Axis a -> b
    com.gutabi.capsloc.world.graph.Side facingSide -> v
    com.gutabi.capsloc.world.graph.FixtureType type -> w
    com.gutabi.capsloc.world.graph.Fixture match -> c
    com.gutabi.capsloc.world.graph.GraphPositionPath shortestPathToMatch -> d
    double lastSpawnTime -> e
    int outstandingCars -> f
    com.gutabi.capsloc.ui.Image img -> g
    com.gutabi.capsloc.geom.AABB intersection -> h
    com.gutabi.capsloc.world.cars.AutonomousCar waitingCar -> i
    boolean $assertionsDisabled -> j
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod -> x
    void setFacingSide(com.gutabi.capsloc.world.graph.Side) -> a
    com.gutabi.capsloc.world.graph.Side getFacingSide() -> a
    boolean supportsStopSigns() -> b
    boolean isUserDeleteable() -> c
    void preStart() -> d
    boolean preStep(double) -> a
    boolean postStep(double) -> c
    com.gutabi.capsloc.world.graph.GraphPositionPath getShortestPathToMatch() -> e
    void spawnNewCar(double) -> b
    boolean active(double) -> d
    com.gutabi.capsloc.world.cars.AutonomousCar createNewCar() -> i
    void render() -> f
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintScene(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod() -> g
com.gutabi.capsloc.world.graph.FixtureType -> com.gutabi.a.d.b.j:
    com.gutabi.capsloc.world.graph.FixtureType SOURCE -> a
    com.gutabi.capsloc.world.graph.FixtureType SINK -> b
    boolean $assertionsDisabled -> c
    com.gutabi.capsloc.world.graph.FixtureType[] ENUM$VALUES -> d
    com.gutabi.capsloc.world.graph.FixtureType[] values() -> values
    com.gutabi.capsloc.world.graph.FixtureType valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.graph.GPPAccumulator -> com.gutabi.a.d.b.k:
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition par -> a
    com.gutabi.capsloc.math.Point p -> b
    int closestIndex -> c
    double closestParam -> d
    double closestDistance -> e
    boolean $assertionsDisabled -> f
    void reset(com.gutabi.capsloc.math.Point) -> a
    void apply(com.gutabi.capsloc.world.graph.GraphPositionPathPosition,com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition result() -> a
com.gutabi.capsloc.world.graph.Graph -> com.gutabi.a.d.b.l:
    com.gutabi.capsloc.world.World world -> a
    java.util.List vertices -> b
    java.util.List roads -> c
    java.util.List mergers -> d
    java.util.List boards -> e
    com.gutabi.capsloc.world.graph.GraphPositionPathFactory pathFactory -> f
    java.util.List paths -> g
    com.gutabi.capsloc.geom.AABB aabb -> h
    com.gutabi.capsloc.ui.Image img -> i
    com.gutabi.capsloc.world.graph.Vertex[] vertexIDs -> j
    double[][] distances -> k
    com.gutabi.capsloc.world.graph.Vertex[][] nextHighest -> l
    boolean $assertionsDisabled -> m
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Direction -> n
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod -> o
    void preStart() -> a
    boolean preStep(double) -> a
    void postStep(double) -> b
    java.util.Set addVertexTop(com.gutabi.capsloc.world.graph.Vertex) -> a
    java.util.Set createRoadTop(com.gutabi.capsloc.world.graph.Road) -> a
    void insertBypassBoardTop(com.gutabi.capsloc.world.graph.BypassBoard) -> a
    boolean automaticMergeOrDestroy(com.gutabi.capsloc.world.graph.Vertex) -> b
    boolean forceMergeOrDestroy(com.gutabi.capsloc.world.graph.Vertex) -> c
    void addVertex(com.gutabi.capsloc.world.graph.Vertex) -> d
    void createRoad(com.gutabi.capsloc.world.graph.Road,int) -> a
    void destroyVertex(com.gutabi.capsloc.world.graph.Vertex) -> e
    void destroyRoad(com.gutabi.capsloc.world.graph.Road) -> b
    void computeAABB() -> e
    com.gutabi.capsloc.world.graph.Vertex shortestPathChoice(com.gutabi.capsloc.world.graph.Vertex,com.gutabi.capsloc.world.graph.Vertex) -> a
    double distanceBetweenVertices(com.gutabi.capsloc.world.graph.Vertex,com.gutabi.capsloc.world.graph.Vertex) -> b
    com.gutabi.capsloc.Entity pureGraphIntersectCircle(com.gutabi.capsloc.geom.Circle) -> a
    com.gutabi.capsloc.Entity pureGraphIntersectCapsule(com.gutabi.capsloc.geom.Capsule) -> a
    com.gutabi.capsloc.world.graph.RoadPosition findClosestRoadPosition(com.gutabi.capsloc.math.Point,double) -> a
    com.gutabi.capsloc.world.graph.Intersection split(com.gutabi.capsloc.world.graph.RoadPosition) -> a
    void refreshVertexIDs() -> f
    void refreshRoadIDs() -> g
    void initializeMatrices() -> h
    void merge(com.gutabi.capsloc.world.graph.Vertex) -> f
    void render() -> b
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintStats(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
    void paintScene(com.gutabi.capsloc.ui.paint.RenderingContext) -> c
    void paintIDs(com.gutabi.capsloc.ui.paint.RenderingContext) -> d
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Direction() -> c
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod() -> d
com.gutabi.capsloc.world.graph.GraphPosition -> com.gutabi.a.d.b.m:
    com.gutabi.capsloc.math.Point p -> i
    com.gutabi.capsloc.Entity entity -> j
    boolean isBound() -> a
    com.gutabi.capsloc.world.graph.GraphPosition approachNeighbor(com.gutabi.capsloc.world.graph.GraphPosition,double) -> a
    double goalGPPPCombo(int,double,boolean,com.gutabi.capsloc.world.graph.GraphPosition,com.gutabi.capsloc.world.graph.GraphPositionPath,com.gutabi.capsloc.world.graph.GraphPositionPathPosition,double) -> a
com.gutabi.capsloc.world.graph.GraphPositionPath -> com.gutabi.a.d.b.n:
    java.util.List poss -> o
    int size -> a
    com.gutabi.capsloc.world.graph.GraphPosition start -> b
    com.gutabi.capsloc.world.graph.GraphPosition end -> c
    double[] cumulativeDistancesFromStart -> d
    double totalLength -> e
    boolean hasLoop -> f
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition startPos -> g
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition endPos -> h
    java.util.Map verticesMap -> i
    java.util.Map edgesMap -> j
    java.util.Map axesMap -> k
    java.util.List borderPositions -> p
    java.util.List currentDrivers -> l
    java.util.Map sharedEdgesMap -> m
    int hash -> q
    java.util.Map hitMap -> r
    boolean $assertionsDisabled -> n
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    com.gutabi.capsloc.world.graph.GraphPosition get(int) -> a
    com.gutabi.capsloc.world.cars.VertexArrivalEvent vertexArrivalTest(com.gutabi.capsloc.world.cars.AutonomousDriver,double) -> a
    int nextVertexIndex(int,double) -> a
    int prevVertexIndex(int,double) -> b
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition findGraphPositionPathPosition(com.gutabi.capsloc.world.graph.GraphPosition,double) -> a
    void precomputeHitTestData() -> a
    java.util.Map precomputeHitTestDataNew() -> c
    void clearHitTestData() -> b
    com.gutabi.capsloc.world.cars.AutonomousDriver driverProximityTest(com.gutabi.capsloc.world.graph.GraphPositionPathPosition,double) -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition hitTest(com.gutabi.capsloc.world.cars.Driver,com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> a
    com.gutabi.capsloc.Entity pureGraphIntersectOBB(com.gutabi.capsloc.geom.MutableOBB,com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> a
com.gutabi.capsloc.world.graph.GraphPositionPathFactory -> com.gutabi.a.d.b.o:
    com.gutabi.capsloc.world.graph.Graph graph -> a
    boolean $assertionsDisabled -> b
    com.gutabi.capsloc.world.graph.GraphPositionPath createShortestVertexPath(java.util.List) -> a
    void calculateShortestVertexPath(java.util.List,com.gutabi.capsloc.world.graph.VertexPosition,com.gutabi.capsloc.world.graph.VertexPosition) -> a
    void fillin(java.util.List,com.gutabi.capsloc.world.graph.VertexPosition,com.gutabi.capsloc.world.graph.VertexPosition,com.gutabi.capsloc.world.graph.Edge,int) -> a
com.gutabi.capsloc.world.graph.GraphPositionPathPosition -> com.gutabi.a.d.b.p:
    com.gutabi.capsloc.world.graph.GraphPositionPath path -> a
    int index -> b
    double param -> c
    double combo -> d
    boolean bound -> e
    com.gutabi.capsloc.math.Point p -> f
    com.gutabi.capsloc.world.graph.GraphPosition gp -> g
    double lengthToStartOfPath -> h
    double lengthToEndOfPath -> i
    double angle -> j
    int hash -> o
    com.gutabi.capsloc.geom.MutableOBB mao -> k
    com.gutabi.capsloc.geom.MutableOBB mbo -> l
    com.gutabi.capsloc.geom.MutableSweptOBB swept -> m
    boolean $assertionsDisabled -> n
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    boolean isEndOfPath() -> a
    com.gutabi.capsloc.math.Point pathVector() -> b
    double lengthTo(com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition travel(double,boolean) -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition travelByVertex(double,boolean) -> b
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition travelByBound(double,boolean,com.gutabi.capsloc.world.graph.GPPAccumulator) -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition travelWithinBound(com.gutabi.capsloc.world.graph.GraphPosition,double,boolean,com.gutabi.capsloc.world.graph.GPPAccumulator) -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition travelForward(double) -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition travelBackward(double) -> b
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition nextBound() -> c
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition prevBound() -> d
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition floor() -> e
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition ceil() -> f
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition floor(double) -> c
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition ceil(double) -> d
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition round(double) -> e
    int prevVertexIndex() -> g
    int nextVertexIndex() -> h
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition prevVertexPosition() -> i
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition nextVertexPosition() -> j
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition forwardSearch(com.gutabi.capsloc.math.Point,double) -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition backwardSearch(com.gutabi.capsloc.math.Point,double) -> b
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition generalSearch(com.gutabi.capsloc.math.Point,double) -> c
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition furthestAllowablePosition(com.gutabi.capsloc.world.cars.Car,com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> a
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition furthestAllowablePositionForward(com.gutabi.capsloc.world.cars.Car,com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> b
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition furthestAllowablePositionBackward(com.gutabi.capsloc.world.cars.Car,com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> c
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition findFirstRightAngleForwardOrEnd(com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> b
    com.gutabi.capsloc.world.graph.GraphPositionPathPosition findFirstRightAngleBackwardOrEnd(com.gutabi.capsloc.world.graph.GraphPositionPathPosition) -> c
    double firstCollisionParam(com.gutabi.capsloc.world.cars.Car,com.gutabi.capsloc.geom.SweptOBB) -> a
    double firstCollisionParam(com.gutabi.capsloc.world.cars.Car,com.gutabi.capsloc.geom.MutableSweptOBB) -> a
    int movesDistance(com.gutabi.capsloc.world.graph.GraphPositionPathPosition,com.gutabi.capsloc.world.cars.Car) -> a
com.gutabi.capsloc.world.graph.Intersection -> com.gutabi.a.d.b.q:
    boolean $assertionsDisabled -> a
    boolean isUserDeleteable() -> c
    boolean supportsStopSigns() -> b
    void preStart() -> d
    boolean preStep(double) -> a
    boolean postStep(double) -> c
    void render() -> f
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintScene(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
com.gutabi.capsloc.world.graph.Merger -> com.gutabi.a.d.b.r:
    com.gutabi.capsloc.math.Point ul -> b
    com.gutabi.capsloc.world.graph.Fixture top -> c
    com.gutabi.capsloc.world.graph.Fixture left -> d
    com.gutabi.capsloc.world.graph.Fixture right -> e
    com.gutabi.capsloc.world.graph.Fixture bottom -> f
    com.gutabi.capsloc.world.graph.Direction leftRightDir -> i
    com.gutabi.capsloc.world.graph.Direction topBottomDir -> j
    double[] cumulativeLengthsFromTop -> k
    double[] cumulativeLengthsFromLeft -> l
    com.gutabi.capsloc.geom.AABB shape -> g
    com.gutabi.capsloc.geom.Line debugSkeletonTopBottomLine -> m
    com.gutabi.capsloc.geom.Line debugSkeletonLeftRightLine -> n
    boolean $assertionsDisabled -> h
    java.lang.String toString() -> toString
    int pointCount() -> a
    double getTotalLength(com.gutabi.capsloc.world.graph.Vertex,com.gutabi.capsloc.world.graph.Vertex) -> a
    com.gutabi.capsloc.world.graph.Vertex getReferenceVertex(com.gutabi.capsloc.world.graph.Axis) -> b
    com.gutabi.capsloc.world.graph.Vertex getOtherVertex(com.gutabi.capsloc.world.graph.Axis) -> c
    com.gutabi.capsloc.world.graph.Direction getDirection(com.gutabi.capsloc.world.graph.Axis) -> a
    void enterDistancesMatrix(double[][]) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelFromReferenceVertex(com.gutabi.capsloc.world.graph.Axis,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelFromOtherVertex(com.gutabi.capsloc.world.graph.Axis,double) -> b
    boolean isUserDeleteable() -> c
    void preStart() -> d
    boolean preStep(double) -> a
    boolean postStep(double) -> c
    com.gutabi.capsloc.math.Point get(int,com.gutabi.capsloc.world.graph.Axis) -> a
    double getLengthFromLeft(int) -> a
    double getLengthFromTop(int) -> b
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintSkeleton(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
com.gutabi.capsloc.world.graph.MergerPosition -> com.gutabi.a.d.b.s:
    com.gutabi.capsloc.world.graph.Merger m -> c
    int index -> d
    double param -> e
    double combo -> f
    double distanceToLeftOfMerger -> g
    double distanceToRightOfMerger -> h
    double distanceToTopOfMerger -> k
    double distanceToBottomOfMerger -> l
    boolean bound -> m
    int hash -> o
    boolean $assertionsDisabled -> n
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    boolean isBound() -> a
    int getIndex() -> d
    double getParam() -> e
    double getCombo() -> f
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundTowardOtherVertex() -> c
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundTowardReferenceVertex() -> b
    com.gutabi.capsloc.world.graph.GraphPosition travelToReferenceVertex(com.gutabi.capsloc.world.graph.Axis,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelToOtherVertex(com.gutabi.capsloc.world.graph.Axis,double) -> b
    com.gutabi.capsloc.world.graph.GraphPosition travelFromTop(com.gutabi.capsloc.world.graph.Merger,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelFromBottom(com.gutabi.capsloc.world.graph.Merger,double) -> b
    com.gutabi.capsloc.world.graph.GraphPosition travelFromLeft(com.gutabi.capsloc.world.graph.Merger,double) -> c
    com.gutabi.capsloc.world.graph.GraphPosition travelFromRight(com.gutabi.capsloc.world.graph.Merger,double) -> d
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundFromTop(com.gutabi.capsloc.world.graph.Merger) -> a
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundFromBottom(com.gutabi.capsloc.world.graph.Merger) -> b
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundFromLeft(com.gutabi.capsloc.world.graph.Merger) -> c
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundFromRight(com.gutabi.capsloc.world.graph.Merger) -> d
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundToLeft(com.gutabi.capsloc.world.graph.Merger,int,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundToRight(com.gutabi.capsloc.world.graph.Merger,int,double) -> b
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundToTop(com.gutabi.capsloc.world.graph.Merger,int,double) -> c
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundToBottom(com.gutabi.capsloc.world.graph.Merger,int,double) -> d
    com.gutabi.capsloc.world.graph.GraphPosition travelToLeft(com.gutabi.capsloc.world.graph.Merger,int,double,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelToRight(com.gutabi.capsloc.world.graph.Merger,int,double,double) -> b
    com.gutabi.capsloc.world.graph.GraphPosition travelToTop(com.gutabi.capsloc.world.graph.Merger,int,double,double) -> c
    com.gutabi.capsloc.world.graph.GraphPosition travelToBottom(com.gutabi.capsloc.world.graph.Merger,int,double,double) -> d
com.gutabi.capsloc.world.graph.RegularStud -> com.gutabi.a.d.b.t:
com.gutabi.capsloc.world.graph.Road -> com.gutabi.a.d.b.u:
    com.gutabi.capsloc.world.World world -> b
    com.gutabi.capsloc.world.graph.Vertex start -> c
    com.gutabi.capsloc.world.graph.Vertex end -> d
    java.util.List raw -> e
    com.gutabi.capsloc.world.graph.Direction direction -> l
    com.gutabi.capsloc.geom.CapsuleSequence seq -> m
    com.gutabi.capsloc.geom.Circle startBorderPoint -> n
    com.gutabi.capsloc.geom.Circle endBorderPoint -> o
    int startBorderIndex -> p
    int endBorderIndex -> q
    double[] cumulativeLengthsFromStart -> r
    double totalLength -> s
    boolean standalone -> t
    boolean loop -> u
    com.gutabi.capsloc.world.graph.StopSign startSign -> f
    com.gutabi.capsloc.world.graph.StopSign endSign -> g
    int hash -> v
    com.gutabi.capsloc.geom.CapsuleSequence shape -> h
    com.gutabi.capsloc.ui.Image img -> i
    com.gutabi.capsloc.geom.AABB intersection -> j
    com.gutabi.capsloc.geom.GeometryPath arrowPointerPath -> w
    boolean $assertionsDisabled -> k
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Direction -> x
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod -> y
    void destroy() -> b
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    boolean isStandAlone() -> e
    int pointCount() -> a
    int capsuleCount() -> f
    double getTotalLength(com.gutabi.capsloc.world.graph.Vertex,com.gutabi.capsloc.world.graph.Vertex) -> a
    com.gutabi.capsloc.math.Point getPoint(int) -> a
    com.gutabi.capsloc.math.Point getPoint(int,double) -> a
    com.gutabi.capsloc.math.Point getStartBorderPoint() -> g
    com.gutabi.capsloc.math.Point getEndBorderPoint() -> h
    void setDirection(com.gutabi.capsloc.world.graph.Axis,com.gutabi.capsloc.world.graph.Direction) -> a
    com.gutabi.capsloc.world.graph.Direction getDirection(com.gutabi.capsloc.world.graph.Axis) -> a
    com.gutabi.capsloc.world.graph.Vertex getReferenceVertex(com.gutabi.capsloc.world.graph.Axis) -> b
    com.gutabi.capsloc.world.graph.Vertex getOtherVertex(com.gutabi.capsloc.world.graph.Axis) -> c
    void preStart() -> d
    boolean preStep(double) -> a
    boolean postStep(double) -> c
    void enterDistancesMatrix(double[][]) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelFromReferenceVertex(com.gutabi.capsloc.world.graph.Axis,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelFromOtherVertex(com.gutabi.capsloc.world.graph.Axis,double) -> b
    com.gutabi.capsloc.world.graph.GraphPosition findSkeletonIntersection(com.gutabi.capsloc.math.Point,com.gutabi.capsloc.math.Point) -> a
    com.gutabi.capsloc.world.graph.RoadPosition findClosestRoadPosition(com.gutabi.capsloc.math.Point,double) -> a
    boolean isUserDeleteable() -> c
    double getLengthFromStart(int) -> b
    void computeProperties() -> i
    void computeCaps() -> m
    java.util.List removeDuplicates(java.util.List) -> a
    java.util.List removeColinear(java.util.List) -> b
    void computeBorders(java.util.List) -> c
    java.util.List adjustToBorders(java.util.List) -> d
    double startBorderCombo(com.gutabi.capsloc.world.graph.Vertex,java.util.List) -> a
    double endBorderCombo(com.gutabi.capsloc.world.graph.Vertex,java.util.List) -> b
    void computeLengths() -> n
    void render() -> j
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintPath_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> d
    void paintSkeleton(com.gutabi.capsloc.ui.paint.RenderingContext) -> e
    void paintBorders(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
    void paintDecorations(com.gutabi.capsloc.ui.paint.RenderingContext) -> c
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$graph$Direction() -> k
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$WorldBackground$RenderMethod() -> l
com.gutabi.capsloc.world.graph.RoadPosition -> com.gutabi.a.d.b.v:
    com.gutabi.capsloc.world.graph.Road r -> c
    int index -> d
    double param -> e
    double combo -> f
    double angle -> g
    boolean bound -> h
    double lengthToStartOfRoad -> k
    double lengthToEndOfRoad -> l
    com.gutabi.capsloc.world.graph.StopSign sign -> m
    int hash -> o
    boolean $assertionsDisabled -> n
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    boolean isBound() -> a
    int getIndex() -> d
    double getParam() -> e
    double getCombo() -> f
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundTowardReferenceVertex() -> b
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundTowardOtherVertex() -> c
    com.gutabi.capsloc.world.graph.GraphPosition travelToReferenceVertex(com.gutabi.capsloc.world.graph.Axis,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelToOtherVertex(com.gutabi.capsloc.world.graph.Axis,double) -> b
    com.gutabi.capsloc.world.graph.GraphPosition travelFromStart(com.gutabi.capsloc.world.graph.Road,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelFromEnd(com.gutabi.capsloc.world.graph.Road,double) -> b
    com.gutabi.capsloc.world.graph.GraphPosition travelForward(com.gutabi.capsloc.world.graph.Road,int,double,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition travelBackward(com.gutabi.capsloc.world.graph.Road,int,double,double) -> b
    com.gutabi.capsloc.world.graph.RoadPosition nextBoundfromStart(com.gutabi.capsloc.world.graph.Road) -> a
    com.gutabi.capsloc.world.graph.RoadPosition nextBoundfromEnd(com.gutabi.capsloc.world.graph.Road) -> b
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundForward(com.gutabi.capsloc.world.graph.Road,int,double) -> a
    com.gutabi.capsloc.world.graph.GraphPosition nextBoundBackward(com.gutabi.capsloc.world.graph.Road,int,double) -> b
    boolean check() -> g
com.gutabi.capsloc.world.graph.Side -> com.gutabi.a.d.b.w:
    com.gutabi.capsloc.world.graph.Side TOP -> a
    com.gutabi.capsloc.world.graph.Side LEFT -> b
    com.gutabi.capsloc.world.graph.Side RIGHT -> c
    com.gutabi.capsloc.world.graph.Side BOTTOM -> d
    boolean $assertionsDisabled -> e
    com.gutabi.capsloc.world.graph.Side[] ENUM$VALUES -> f
    com.gutabi.capsloc.world.graph.Side[] values() -> values
    com.gutabi.capsloc.world.graph.Side valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.graph.Side$1 -> com.gutabi.a.d.b.x:
com.gutabi.capsloc.world.graph.Side$2 -> com.gutabi.a.d.b.y:
com.gutabi.capsloc.world.graph.Side$3 -> com.gutabi.a.d.b.z:
com.gutabi.capsloc.world.graph.Side$4 -> com.gutabi.a.d.b.aa:
com.gutabi.capsloc.world.graph.StopSign -> com.gutabi.a.d.b.ab:
    com.gutabi.capsloc.world.graph.Road r -> a
    com.gutabi.capsloc.world.graph.Vertex v -> b
    int dir -> c
    com.gutabi.capsloc.math.Point p -> d
    double radius -> e
    boolean enabled -> g
    com.gutabi.capsloc.geom.Circle shape -> f
    boolean isUserDeleteable() -> c
    boolean isEnabled() -> a
    void setEnabled(boolean) -> a
    void preStart() -> d
    boolean preStep(double) -> a
    boolean postStep(double) -> c
    void computePoint() -> b
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.world.graph.Vertex -> com.gutabi.a.d.b.ac:
    double INIT_VERTEX_RADIUS -> k
    com.gutabi.capsloc.world.World world -> l
    com.gutabi.capsloc.math.Point p -> m
    java.util.List roads -> n
    com.gutabi.capsloc.world.graph.Merger m -> o
    com.gutabi.capsloc.world.graph.BypassStud s -> p
    int id -> q
    double r -> r
    java.util.List driverQueue -> s
    com.gutabi.capsloc.geom.Circle shape -> t
    int hash -> a
    boolean $assertionsDisabled -> u
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    double getRadius() -> h
    com.gutabi.capsloc.world.graph.Road bestMatchingRoad(com.gutabi.capsloc.world.graph.Road,com.gutabi.capsloc.world.graph.Road) -> a
    boolean supportsStopSigns() -> b
    java.util.List commonEdges(com.gutabi.capsloc.world.graph.Vertex,com.gutabi.capsloc.world.graph.Vertex) -> a
    void render() -> f
    void paint_panel(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
    void paintScene(com.gutabi.capsloc.ui.paint.RenderingContext) -> b
    void paintID(com.gutabi.capsloc.ui.paint.RenderingContext) -> c
com.gutabi.capsloc.world.graph.VertexPosition -> com.gutabi.a.d.b.ad:
    com.gutabi.capsloc.world.graph.Vertex v -> a
    int hash -> c
    boolean $assertionsDisabled -> b
    int hashCode() -> hashCode
    boolean isBound() -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    com.gutabi.capsloc.world.graph.GraphPosition approachNeighbor(com.gutabi.capsloc.world.graph.GraphPosition,double) -> a
    double goalGPPPCombo(int,double,boolean,com.gutabi.capsloc.world.graph.GraphPosition,com.gutabi.capsloc.world.graph.GraphPositionPath,com.gutabi.capsloc.world.graph.GraphPositionPathPosition,double) -> a
com.gutabi.capsloc.world.physics.PhysicsBody -> com.gutabi.a.d.c.a:
    com.gutabi.capsloc.world.World world -> A
    double length -> B
    double width -> C
    double localULX -> D
    double localULY -> E
    com.gutabi.capsloc.math.Point center -> F
    double angle -> G
    com.gutabi.capsloc.geom.MutableOBB shape -> H
    double forwardSpeed -> I
    double angularVel -> J
    com.gutabi.capsloc.geom.AABB localAABB -> K
    com.gutabi.capsloc.math.Point vel -> L
    void physicsInit() -> h
    void computeDynamicPropertiesAlways() -> i
    void computeDynamicPropertiesMoving() -> j
    void setPhysicsTransform() -> k
    void setB2dCollisions(boolean) -> a
    void destroy() -> f
    void applyForwardImpulse(double,double) -> a
    void applyAngularImpulse(double,double) -> b
    void applyCancelingForwardImpulse(double) -> d
    void applyCancelingLateralImpulse(double) -> e
    void applyCancelingAngularImpulse(double) -> f
com.gutabi.capsloc.world.physics.PhysicsWorld -> com.gutabi.a.d.c.b:
    double t -> A
    boolean $assertionsDisabled -> B
    boolean step() -> l
    double getTime() -> d
    int getBodyCount() -> m
    void drawPhysicsDebug(com.gutabi.capsloc.ui.paint.RenderingContext) -> c
    boolean intersectsPhysicsBodies(com.gutabi.capsloc.geom.AABB) -> a
    boolean intersectsPhysicsBodies(com.gutabi.capsloc.geom.MutableAABB) -> a
com.gutabi.capsloc.world.sprites.AnimatedGrass -> com.gutabi.a.d.d.a:
    double GRASS_SIZE -> a
    com.gutabi.capsloc.math.Point p -> b
    int lastFrame -> c
    double lastTime -> d
    double phase -> e
    int startFrame -> f
    com.gutabi.capsloc.geom.AABB aabb -> g
    boolean xor -> h
    void preStart() -> a
    boolean step(double) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext) -> a
com.gutabi.capsloc.world.sprites.CarSheet -> com.gutabi.a.d.d.b:
    boolean $assertionsDisabled -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$sprites$CarSheet$CarType -> d
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite sprite(int) -> a
    int sheetIndex(com.gutabi.capsloc.world.sprites.CarSheet$CarType,int) -> a
    int[] $SWITCH_TABLE$com$gutabi$capsloc$world$sprites$CarSheet$CarType() -> a
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite -> com.gutabi.a.d.d.c:
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite RED -> a
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite CAR0 -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite CAR1 -> c
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite CAR2 -> d
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite CAR3 -> e
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite CAR4 -> f
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite CAR5 -> g
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite CAR6 -> h
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite TRUCK0 -> i
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite TRUCK1 -> j
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite TRUCK2 -> k
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite TRUCK3 -> l
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite TRUCK4 -> m
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite TRUCK5 -> n
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite TRUCK6 -> o
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite[] ENUM$VALUES -> p
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite[] values() -> values
    com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$1 -> com.gutabi.a.d.d.d:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$10 -> com.gutabi.a.d.d.e:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$11 -> com.gutabi.a.d.d.f:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$12 -> com.gutabi.a.d.d.g:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$13 -> com.gutabi.a.d.d.h:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$14 -> com.gutabi.a.d.d.i:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$15 -> com.gutabi.a.d.d.j:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$2 -> com.gutabi.a.d.d.k:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$3 -> com.gutabi.a.d.d.l:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$4 -> com.gutabi.a.d.d.m:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$5 -> com.gutabi.a.d.d.n:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$6 -> com.gutabi.a.d.d.o:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$7 -> com.gutabi.a.d.d.p:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$8 -> com.gutabi.a.d.d.q:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarSheetSprite$9 -> com.gutabi.a.d.d.r:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
    int carLength() -> a
    int carWidth() -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType type() -> c
com.gutabi.capsloc.world.sprites.CarSheet$CarType -> com.gutabi.a.d.d.s:
    com.gutabi.capsloc.world.sprites.CarSheet$CarType TWO -> a
    com.gutabi.capsloc.world.sprites.CarSheet$CarType THREE -> b
    com.gutabi.capsloc.world.sprites.CarSheet$CarType RED -> c
    com.gutabi.capsloc.world.sprites.CarSheet$CarType[] ENUM$VALUES -> d
    com.gutabi.capsloc.world.sprites.CarSheet$CarType[] values() -> values
    com.gutabi.capsloc.world.sprites.CarSheet$CarType valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.sprites.Sheet -> com.gutabi.a.d.d.t:
    com.gutabi.capsloc.Resource res -> b
    com.gutabi.capsloc.ui.Image img -> c
    void load() -> b
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext,com.gutabi.capsloc.world.sprites.Sprite,int,int,int,int) -> a
    void paint(com.gutabi.capsloc.ui.paint.RenderingContext,com.gutabi.capsloc.world.sprites.Sprite,double,double,double,double,double) -> a
com.gutabi.capsloc.world.sprites.Sprite -> com.gutabi.a.d.d.u:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet -> com.gutabi.a.d.d.v:
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite -> com.gutabi.a.d.d.w:
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite INNERSTUD -> a
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite TOPSTUD -> b
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite RIGHTSTUD -> c
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite BOTTOMSTUD -> d
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite LEFTSTUD -> e
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite GRASSTILE -> f
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite GRASS0 -> g
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite GRASS1 -> h
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite GRASS2 -> i
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite BLUEARROW -> j
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite BRAKE -> k
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite FIXTUREARROW -> l
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite STOPSIGN -> m
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite[] ENUM$VALUES -> n
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite[] values() -> values
    com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$1 -> com.gutabi.a.d.d.x:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$10 -> com.gutabi.a.d.d.y:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$11 -> com.gutabi.a.d.d.z:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$12 -> com.gutabi.a.d.d.aa:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$13 -> com.gutabi.a.d.d.ab:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$2 -> com.gutabi.a.d.d.ac:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$3 -> com.gutabi.a.d.d.ad:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$4 -> com.gutabi.a.d.d.ae:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$5 -> com.gutabi.a.d.d.af:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$6 -> com.gutabi.a.d.d.ag:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$7 -> com.gutabi.a.d.d.ah:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$8 -> com.gutabi.a.d.d.ai:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.sprites.SpriteSheet$SpriteSheetSprite$9 -> com.gutabi.a.d.d.aj:
    int xStart() -> d
    int yStart() -> e
    int xEnd() -> f
    int yEnd() -> g
com.gutabi.capsloc.world.tools.Motion -> com.gutabi.a.d.e.a:
    com.gutabi.capsloc.world.tools.Motion PRESSED -> a
    com.gutabi.capsloc.world.tools.Motion DRAGGED -> b
    com.gutabi.capsloc.world.tools.Motion RELEASED -> c
    com.gutabi.capsloc.world.tools.Motion[] ENUM$VALUES -> d
    com.gutabi.capsloc.world.tools.Motion[] values() -> values
    com.gutabi.capsloc.world.tools.Motion valueOf(java.lang.String) -> valueOf
com.gutabi.capsloc.world.tools.WorldToolBase -> com.gutabi.a.d.e.b:
    com.gutabi.capsloc.world.tools.Motion lastMotion -> m
    void pressed(com.gutabi.capsloc.ui.InputEvent) -> a
    void dragged(com.gutabi.capsloc.ui.InputEvent) -> c
    void released(com.gutabi.capsloc.ui.InputEvent) -> b
